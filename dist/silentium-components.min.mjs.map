{"version":3,"file":"silentium-components.min.mjs","sources":["../src/controls/GroupActiveClass.ts","../src/behaviors/Dirty.ts","../src/behaviors/Loading.ts","../src/behaviors/Path.ts","../src/behaviors/Deadline.ts","../src/structures/HashTable.ts"],"sourcesContent":["import { patron, sourceAll, SourceType, value } from \"silentium\";\n\n/**\n * Sets activeClass to one element of group\n * and resets activeClass on other group elements\n * suitable for menu active class\n */\nexport const groupActiveClass = (\n  activeClassSrc: SourceType<string>,\n  activeElementSrc: SourceType<HTMLElement>,\n  groupElementsSrc: SourceType<HTMLElement[]>,\n) => {\n  value(\n    sourceAll([activeClassSrc, activeElementSrc, groupElementsSrc]),\n    patron(([activeClass, activeElement, groupElements]) => {\n      groupElements.forEach((el) => {\n        if (el.classList) {\n          el.classList.remove(activeClass);\n        }\n      });\n      activeElement.classList.add(activeClass);\n    }),\n  );\n\n  return groupElementsSrc;\n};\n","import {\n  give,\n  guestCast,\n  GuestType,\n  patronOnce,\n  sourceAll,\n  SourceChangeableType,\n  sourceOf,\n  SourceType,\n  value,\n} from \"silentium\";\n\n/**\n * Takes source and remember it first value\n * returns new record, what will contain only fields what was changed\n */\nexport const dirty = <T extends object>(\n  baseEntitySource: SourceType<T>,\n  becomePatronAuto = false,\n  alwaysKeep: string[] = [],\n  excludeKeys: string[] = [],\n): SourceChangeableType<Partial<T>> => {\n  const comparingSrc = sourceOf();\n  const all = sourceAll([comparingSrc, baseEntitySource]);\n\n  const result = {\n    give(value: T) {\n      give(JSON.parse(JSON.stringify(value)), comparingSrc);\n      return result;\n    },\n    value(guest: GuestType<Partial<T>>) {\n      value(\n        all,\n        guestCast(guest, ([comparing, base]) => {\n          if (!comparing) {\n            return;\n          }\n\n          give(\n            Object.fromEntries(\n              Object.entries(comparing).filter(([key, value]) => {\n                if (alwaysKeep.includes(key)) {\n                  return true;\n                }\n                if (excludeKeys.includes(key)) {\n                  return false;\n                }\n                return value !== (base as any)[key];\n              }),\n            ) as T,\n            guest,\n          );\n        }),\n      );\n      return result;\n    },\n  };\n\n  if (becomePatronAuto) {\n    value(baseEntitySource, patronOnce(result));\n  }\n\n  return result;\n};\n","import { patron, sourceOf, SourceType, subSourceMany, value } from \"silentium\";\n\n/**\n * https://silentium-lab.github.io/silentium-components/#/behaviors/loading\n */\nexport const loading = (\n  loadingStartSource: SourceType<unknown>,\n  loadingFinishSource: SourceType<unknown>,\n) => {\n  const loadingSrc = sourceOf<boolean>();\n  subSourceMany(loadingSrc, [loadingStartSource, loadingFinishSource]);\n\n  value(\n    loadingStartSource,\n    patron(() => {\n      loadingSrc.give(true);\n    }),\n  );\n  value(\n    loadingFinishSource,\n    patron(() => {\n      loadingSrc.give(false);\n    }),\n  );\n\n  return loadingSrc.value;\n};\n","import {\n  give,\n  patron,\n  sourceAll,\n  sourceOf,\n  SourceType,\n  subSourceMany,\n  value,\n} from \"silentium\";\n\nexport const path = <T extends Record<string, unknown>, K extends string>(\n  baseSrc: SourceType<T>,\n  keySrc: SourceType<K>,\n) => {\n  const pathSrc = sourceOf<T[K]>();\n  subSourceMany(pathSrc, [baseSrc, keySrc]);\n\n  value(\n    sourceAll([baseSrc, keySrc]),\n    patron(([base, key]) => {\n      const keyChunks = key.split(\".\");\n      let value: unknown = base;\n      keyChunks.forEach((keyChunk) => {\n        value = (value as T)[keyChunk];\n      });\n\n      if (value !== undefined && value !== base) {\n        give(value as T[K], pathSrc);\n      }\n    }),\n  );\n\n  return pathSrc.value;\n};\n","import {\n  give,\n  guestCast,\n  GuestType,\n  patronOnce,\n  sourceFiltered,\n  SourceType,\n  value,\n} from \"silentium\";\n\nexport const deadline = <T>(\n  error: GuestType<Error>,\n  baseSrc: SourceType<T>,\n  timeoutSrc: SourceType<number>,\n) => {\n  let timerHead: unknown = null;\n  return (g: GuestType<T>) => {\n    value(\n      timeoutSrc,\n      guestCast(g, (timeout) => {\n        if (timerHead) {\n          clearTimeout(timerHead as number);\n        }\n\n        let timeoutReached = false;\n\n        timerHead = setTimeout(() => {\n          if (timeoutReached) {\n            return;\n          }\n          timeoutReached = true;\n          give(new Error(\"Timeout reached in Deadline class\"), error);\n        }, timeout);\n\n        value(\n          sourceFiltered(baseSrc, () => !timeoutReached),\n          g,\n        );\n\n        value(\n          baseSrc,\n          patronOnce(() => {\n            timeoutReached = true;\n          }),\n        );\n      }),\n    );\n  };\n};\n","import { patron, sourceOf, SourceType, subSource, value } from \"silentium\";\n\n/**\n * https://silentium-lab.github.io/silentium-components/#/structures/hash-table\n */\nexport const hashTable = (baseSource: SourceType<[string, unknown]>) => {\n  const result = sourceOf<Record<string, unknown>>({});\n  subSource(result, baseSource);\n\n  value(\n    baseSource,\n    patron(([key, value]) => {\n      result.value((lastRecord) => {\n        lastRecord[key] = value;\n      });\n    }),\n  );\n\n  return result.value;\n};\n"],"names":["groupActiveClass","activeClassSrc","activeElementSrc","groupElementsSrc","value","sourceAll","patron","activeClass","activeElement","groupElements","forEach","el","classList","remove","add","dirty","baseEntitySource","becomePatronAuto","alwaysKeep","excludeKeys","comparingSrc","sourceOf","all","result","give","JSON","parse","stringify","guest","guestCast","comparing","base","Object","fromEntries","entries","filter","key","includes","patronOnce","loading","loadingStartSource","loadingFinishSource","loadingSrc","subSourceMany","path","baseSrc","keySrc","pathSrc","keyChunks","split","keyChunk","deadline","error","timeoutSrc","timerHead","g","timeout","clearTimeout","timeoutReached","setTimeout","Error","sourceFiltered","hashTable","baseSource","subSource","lastRecord"],"mappings":"0KAOO,MAAMA,EAAmB,CAC9BC,EACAC,EACAC,KAEAC,EACEC,EAAU,CAACJ,EAAgBC,EAAkBC,IAC7CG,GAAO,EAAEC,EAAaC,EAAeC,MACrBA,EAAAC,SAASC,IACjBA,EAAGC,WACFD,EAAAC,UAAUC,OAAON,EAAW,IAGrBC,EAAAI,UAAUE,IAAIP,EAAW,KAIpCJ,GCRIY,EAAQ,CACnBC,EACAC,GAAmB,EACnBC,EAAuB,GACvBC,EAAwB,MAExB,MAAMC,EAAeC,IACfC,EAAMjB,EAAU,CAACe,EAAcJ,IAE/BO,EAAS,CACbC,KAAKpB,IACHoB,EAAKC,KAAKC,MAAMD,KAAKE,UAAUvB,IAASgB,GACjCG,GAETnB,MAAMwB,IACJxB,EACEkB,EACAO,EAAUD,GAAO,EAAEE,EAAWC,MACvBD,GAILN,EACEQ,OAAOC,YACLD,OAAOE,QAAQJ,GAAWK,QAAO,EAAEC,EAAKhC,OAClCc,EAAWmB,SAASD,KAGpBjB,EAAYkB,SAASD,IAGlBhC,IAAW2B,EAAaK,MAGnCR,EACF,KAGGL,IAQJ,OAJHN,GACIb,EAAAY,EAAkBsB,EAAWf,IAG9BA,CAAA,ECzDIgB,EAAU,CACrBC,EACAC,KAEA,MAAMC,EAAarB,IAgBnB,OAfAsB,EAAcD,EAAY,CAACF,EAAoBC,IAE/CrC,EACEoC,EACAlC,GAAO,KACLoC,EAAWlB,MAAK,EAAI,KAGxBpB,EACEqC,EACAnC,GAAO,KACLoC,EAAWlB,MAAK,EAAK,KAIlBkB,EAAWtC,KAAA,ECfPwC,EAAO,CAClBC,EACAC,KAEA,MAAMC,EAAU1B,IAkBhB,OAjBAsB,EAAcI,EAAS,CAACF,EAASC,IAEjC1C,EACEC,EAAU,CAACwC,EAASC,IACpBxC,GAAO,EAAEyB,EAAMK,MACP,MAAAY,EAAYZ,EAAIa,MAAM,KAC5B,IAAI7C,EAAiB2B,EACXiB,EAAAtC,SAASwC,IACjB9C,EAASA,EAAY8C,EAAQ,SAGjB,IAAV9C,GAAuBA,IAAU2B,GACnCP,EAAKpB,EAAe2C,EAAO,KAK1BA,EAAQ3C,KAAA,ECtBJ+C,EAAW,CACtBC,EACAP,EACAQ,KAEA,IAAIC,EAAqB,KACzB,OAAQC,IACNnD,EACEiD,EACAxB,EAAU0B,GAAIC,IACRF,GACFG,aAAaH,GAGf,IAAII,GAAiB,EAErBJ,EAAYK,YAAW,KACjBD,IAGaA,GAAA,EACjBlC,EAAK,IAAIoC,MAAM,qCAAsCR,GAAK,GACzDI,GAEHpD,EACEyD,EAAehB,GAAS,KAAOa,IAC/BH,GAGFnD,EACEyC,EACAP,GAAW,KACQoB,GAAA,CAAA,IAErB,IAEJ,CACF,EC1CWI,EAAaC,IAClB,MAAAxC,EAASF,EAAkC,IAYjD,OAXA2C,EAAUzC,EAAQwC,GAElB3D,EACE2D,EACAzD,GAAO,EAAE8B,EAAKhC,MACLmB,EAAAnB,OAAO6D,IACZA,EAAW7B,GAAOhC,CAAAA,GACnB,KAIEmB,EAAOnB,KAAA"}