{"version":3,"file":"silentium-components.min.mjs","sources":["../src/behaviors/Branch.ts","../src/behaviors/BranchLazy.ts","../src/behaviors/Const.ts","../src/behaviors/Deadline.ts","../src/behaviors/Deferred.ts","../src/behaviors/Detached.ts","../src/behaviors/Dirty.ts","../src/behaviors/Loading.ts","../src/behaviors/Lock.ts","../src/behaviors/Memo.ts","../src/behaviors/MergeAccumulation.ts","../src/behaviors/OnlyChanged.ts","../src/behaviors/Part.ts","../src/behaviors/Path.ts","../src/behaviors/Polling.ts","../src/behaviors/RecordTruncated.ts","../src/behaviors/StateRecord.ts","../src/behaviors/Switch.ts","../src/behaviors/Task.ts","../src/behaviors/Tick.ts","../src/structures/HashTable.ts","../src/structures/Record.ts","../src/behaviors/Transformed.ts","../src/behaviors/TransformedList.ts","../src/boolean/And.ts","../src/boolean/Bool.ts","../src/boolean/Not.ts","../src/boolean/Or.ts","../src/formats/FromJson.ts","../src/formats/ToJson.ts","../src/lists/First.ts","../src/system/RegexpMatch.ts","../src/system/RegexpMatched.ts","../src/system/RegexpReplaced.ts","../src/system/Set.ts","../src/navigation/Router.ts","../src/strings/Concatenated.ts","../src/strings/Template.ts"],"sourcesContent":["import {\n  Actual,\n  MaybeMessage,\n  Message,\n  MessageType,\n  Primitive,\n} from \"silentium\";\n\n/**\n * Allows switching between left and right messages depending on condition\n * https://silentium.pw/article/branch/view\n */\nexport function Branch<Then, Else>(\n  _condition: MaybeMessage<boolean>,\n  _left: MaybeMessage<Then>,\n  _right?: MaybeMessage<Else>,\n) {\n  const $condition = Actual(_condition);\n  const $left = Actual(_left);\n  const $right = Actual(_right);\n  return Message<Then | Else>(function BranchImpl(r) {\n    const left = Primitive($left);\n    let right: ReturnType<typeof Primitive<Else>>;\n    if (_right !== undefined) {\n      right = Primitive($right as MessageType<Else>);\n    }\n    $condition.then((v) => {\n      if (typeof v !== \"boolean\") {\n        throw new Error(\"Branch received not boolean value\");\n      }\n      let result: Then | Else | null = null;\n      if (v === true) {\n        result = left.primitive();\n      } else if (right) {\n        result = right.primitive();\n      }\n      if (result !== null) {\n        r(result);\n      }\n    });\n  });\n}\n","import {\n  ConstructorType,\n  DestroyableType,\n  DestroyContainer,\n  Message,\n  MessageType,\n} from \"silentium\";\n\n/**\n * Depending on the $condition message,\n * creates a new left or right message.\n * When condition changes, old messages are destroyed\n * and new ones are created.\n */\nexport function BranchLazy<Then, Else>(\n  $condition: MessageType<boolean>,\n  $left: ConstructorType<[], MessageType<Then>>,\n  $right?: ConstructorType<[], MessageType<Else>>,\n): MessageType<Then | Else> & DestroyableType {\n  return Message(function BranchLazyImpl(r) {\n    const dc = DestroyContainer();\n    const destructor = () => {\n      dc.destroy();\n    };\n    $condition.then((v) => {\n      destructor();\n      let instance: MessageType<Then | Else> | undefined;\n      if (v) {\n        instance = $left();\n      } else if ($right) {\n        instance = $right();\n      }\n      if (instance !== undefined) {\n        instance.then(r);\n        dc.add(instance);\n      }\n    });\n    return destructor;\n  });\n}\n","import { Message, MessageType, ResetSilenceCache } from \"silentium\";\n\n/**\n * Constant value that will be\n * returned on each value from\n * the $trigger message\n */\nexport function Constant<T>(\n  permanent: T,\n  $trigger: MessageType,\n): MessageType<T> {\n  return Message<T>(function ConstantImpl(resolve, reject) {\n    $trigger.catch(reject).then(() => {\n      resolve(permanent);\n      // Do cache reset, it gives ability to send constant of same value many times\n      resolve(ResetSilenceCache as T);\n    });\n  });\n}\n","import {\n  Actual,\n  Filtered,\n  MaybeMessage,\n  Message,\n  MessageType,\n  Shared,\n} from \"silentium\";\n\n/**\n * Will return an error via error transport if\n * time runs out from $timeout; if $base manages to\n * respond before $timeout then the value from base will be returned\n */\nexport function Deadline<T>(\n  $base: MessageType<T>,\n  _timeout: MaybeMessage<number>,\n) {\n  const $timeout = Actual(_timeout);\n  return Message<T>(function DeadlineImpl(resolve, reject) {\n    let timer: ReturnType<typeof setTimeout> | number = 0;\n    const base = Shared($base);\n    $timeout.then((timeout) => {\n      if (timer) {\n        clearTimeout(timer);\n      }\n      let timeoutReached = false;\n\n      timer = setTimeout(() => {\n        if (timeoutReached) {\n          return;\n        }\n        timeoutReached = true;\n        reject(new Error(\"Timeout reached in Deadline\"));\n      }, timeout);\n\n      const f = Filtered(base, () => !timeoutReached);\n      f.then(resolve);\n\n      base.then(() => {\n        timeoutReached = true;\n      });\n    });\n  });\n}\n","import { isFilled, Message, MessageType, Primitive } from \"silentium\";\n\n/**\n * Defer one source after another, gives values Of baseSrc only when triggerSrc responds\n * https://silentium-lab.github.io/silentium-components/#/behaviors/deferred\n */\nexport function Deferred<T>(\n  $base: MessageType<T>,\n  $trigger: MessageType<unknown>,\n) {\n  return Message<T>(function DeferredImpl(r) {\n    const base = Primitive($base);\n    $trigger.then(() => {\n      const value = base.primitive();\n      if (isFilled(value)) {\n        r(value);\n      }\n    });\n  });\n}\n","import { isFilled, Message, MessageType, Primitive } from \"silentium\";\n\n/**\n * Message separate from the base\n * allows to take one value from the base\n * but not react to new values of the base message\n */\nexport function Detached<T>($base: MessageType<T>): MessageType<T> {\n  return Message<T>(function DetachedImpl(r) {\n    const v = Primitive($base).primitive();\n    if (isFilled(v)) {\n      r(v);\n    }\n  });\n}\n","import { All, Applied, Late, MessageType, Source } from \"silentium\";\n\n/**\n * Takes source and remember it first value\n * returns new record, what will contain only fields what was changed\n * https://silentium-lab.github.io/silentium-components/#/behaviors/dirty\n */\nexport function Dirty<T extends Record<string, unknown>>(\n  $base: MessageType<T>,\n  keep: string[] = [],\n  exclude: string[] = [],\n  cloner?: (v: T) => T,\n) {\n  const $comparing = Late<T>({} as T);\n  if (cloner === undefined) {\n    cloner = (value) => JSON.parse(JSON.stringify(value));\n  }\n  return Source<T>(\n    function DirtyImpl(r) {\n      const $comparingClone = Applied($comparing, cloner);\n      All($comparingClone, $base).then(([comparing, base]) => {\n        if (!comparing) {\n          return;\n        }\n        r(\n          Object.fromEntries(\n            Object.entries(comparing).filter(([key, value]) => {\n              if (keep.includes(key)) {\n                return true;\n              }\n              if (exclude.includes(key)) {\n                return false;\n              }\n              return value !== (base as Record<string, unknown>)[key];\n            }),\n          ) as T,\n        );\n      });\n    },\n    (v) => {\n      $comparing.use(v);\n    },\n  );\n}\n","import { Message, MessageType } from \"silentium\";\n\n/**\n * Representation Of loading process\n * first message begins loading\n * second message stops loading\n * https://silentium-lab.github.io/silentium-components/#/behaviors/loading\n */\nexport function Loading(\n  $start: MessageType<unknown>,\n  $finish: MessageType<unknown>,\n) {\n  return Message<boolean>(function LoadingImpl(r) {\n    $start.then(() => r(true));\n    $finish.then(() => r(false));\n  });\n}\n","import { Filtered, Message, MessageType } from \"silentium\";\n\n/**\n * Allows locking messages\n * if a $lock message arrives\n * https://silentium-lab.github.io/silentium-components/#/behaviors/lock\n */\nexport function Lock<T>($base: MessageType<T>, $lock: MessageType<boolean>) {\n  return Message<T>(function LockImpl(r) {\n    let locked = false;\n    $lock.then((newLock) => {\n      locked = newLock;\n    });\n    const i = Filtered($base, () => !locked);\n    i.then(r);\n  });\n}\n","import { isFilled, Message, MessageType } from \"silentium\";\n\n/**\n * Didn't respond if new value Of baseSrc equals to old value\n * https://silentium-lab.github.io/silentium-components/#/behaviors/memo\n */\nexport function Memo<T>($base: MessageType<T>) {\n  return Message<T>(function MemoImpl(r) {\n    let last: T | null = null;\n    $base.then((v) => {\n      if (v !== last && isFilled(v)) {\n        r(v);\n        last = v;\n      }\n    });\n  });\n}\n","import { Late, MessageType } from \"silentium\";\n\n/**\n * Есть объект и каждое новое его значение нужно мержить с прошлым\n * чтобы накопить общие изменения\n */\nexport function MergeAccumulation<T extends object>(\n  $base: MessageType<T>,\n  $reset?: MessageType<T>,\n): MessageType<T> {\n  const accumulation = Late<T>();\n  const lastAccumulated = {};\n  $base.then((nextValue) => {\n    accumulation.use(\n      mergeWith(lastAccumulated, nextValue, (value1: any, value2: any) => {\n        if (Array.isArray(value1)) {\n          return value1.concat(value2);\n        }\n      }),\n    );\n  });\n\n  if ($reset) {\n    $reset.then((resetValue) => {\n      accumulation.use(resetValue);\n    });\n  }\n\n  return accumulation;\n}\n\nfunction mergeWith<TObject, TSource>(\n  target: TObject,\n  source: TSource,\n  customizer: (\n    objValue: any,\n    srcValue: any,\n    key: string,\n    object: any,\n    source: any,\n  ) => any,\n): TObject & TSource {\n  if (source == null) {\n    return target as TObject & TSource;\n  }\n\n  Object.keys(source).forEach((key) => {\n    const srcValue = (source as any)[key];\n    const objValue = (target as any)[key];\n    const result = customizer(objValue, srcValue, key, target, source);\n\n    if (result !== undefined) {\n      (target as any)[key] = result;\n    } else if (isObject(srcValue) && isObject(objValue)) {\n      mergeWith(objValue, srcValue, customizer);\n    } else {\n      (target as any)[key] = srcValue;\n    }\n  });\n\n  return target as TObject & TSource;\n}\n\nfunction isObject(value: any): value is \"object\" {\n  return value != null && typeof value === \"object\";\n}\n","import { Message, MessageType } from \"silentium\";\n\n/**\n * Represents source what was changed at least once\n * @url https://silentium.pw/article/only-changed/view\n */\nexport function OnlyChanged<T>($base: MessageType<T>) {\n  return Message<T>(function OnlyChangedImpl(r) {\n    let first = false;\n    $base.then((v) => {\n      if (first === false) {\n        first = true;\n      } else {\n        r(v);\n      }\n    });\n  });\n}\n","import {\n  Actual,\n  All,\n  isFilled,\n  MaybeMessage,\n  MessageSourceType,\n  Primitive,\n  Shared,\n  Source,\n} from \"silentium\";\n\n/**\n * Return source Of record path\n * @url https://silentium.pw/article/part/view\n */\nexport function Part<\n  R,\n  T extends object | Array<any> = any,\n  K extends string = any,\n>(\n  $base: MessageSourceType<T>,\n  key: MaybeMessage<K>,\n  defaultValue?: R,\n): MessageSourceType<R> {\n  const $baseShared = Shared($base);\n  const $keyedShared = Shared(Actual(key));\n  return Source(\n    function PartImpl(r) {\n      All($baseShared, $keyedShared).then(([base, keyed]) => {\n        const keys = keyed.split(\".\");\n        let value: unknown = base;\n        keys.forEach((key: string) => {\n          value = (value as Record<string, unknown>)[key];\n        });\n        if (value !== undefined && value !== base) {\n          r(value as R);\n        } else if (defaultValue !== undefined) {\n          r(defaultValue);\n        }\n      });\n    },\n    (value) => {\n      const key = Primitive($keyedShared);\n      if (isFilled(key)) {\n        const base = Primitive($base);\n        $base.use({\n          ...base.primitiveWithException(),\n          [key.primitiveWithException()]: value,\n        } as T);\n      }\n    },\n  );\n}\n","import { Actual, All, Applied, MaybeMessage, MessageType } from \"silentium\";\n\nconst NotSet = Symbol(\"not-set\");\n\n/**\n * Return source Of record path\n * https://silentium-lab.github.io/silentium-components/#/behaviors/path\n */\nexport function Path<\n  R,\n  T extends object | Array<any> = any,\n  K extends string = any,\n>(_base: MaybeMessage<T>, _keyed: MaybeMessage<K>, def?: MaybeMessage<R>) {\n  const $base = Actual(_base);\n  const $keyed = Actual(_keyed);\n  const $def = Actual((def as any) ?? NotSet);\n  return Applied(All($base, $keyed, $def), ([base, keyed, d]) => {\n    const keys = keyed.split(\".\");\n    let value: unknown = base;\n    keys.forEach((key) => {\n      value = (value as Record<string, unknown>)[key];\n    });\n    if (value !== undefined && value !== base) {\n      return value as R;\n    } else if (d !== NotSet) {\n      return d as R;\n    }\n  }) as MessageType<R>;\n}\n","import {\n  DestroyContainer,\n  Message,\n  MessageType,\n  ResetSilenceCache,\n} from \"silentium\";\n\n/**\n * Active polling of $base message\n * synchronized with $trigger message\n * can return same values\n */\nexport function Polling<T>(\n  $base: MessageType<T>,\n  $trigger: MessageType<unknown>,\n) {\n  return Message<T>(function PollingImpl(resolve, reject) {\n    const dc = DestroyContainer();\n    $trigger\n      .then(() => {\n        dc.destroy();\n        resolve(ResetSilenceCache as T);\n        dc.add($base.then(resolve).catch(reject));\n      })\n      .catch(reject);\n  });\n}\n","import { Actual, Computed, MaybeMessage } from \"silentium\";\n\n/**\n * Helps eliminate unwanted values\n * that shouldn't exist in object fields\n */\nexport function RecordTruncated(\n  _record: MaybeMessage<Record<string, unknown>>,\n  _badValues: MaybeMessage<unknown[]>,\n) {\n  const $record = Actual(_record);\n  const $badValues = Actual(_badValues);\n  const processRecord = (obj: any, badValues: unknown[]) => {\n    if (obj === null || typeof obj !== \"object\" || Array.isArray(obj)) {\n      return obj;\n    }\n\n    const result: Record<string, unknown> = {};\n\n    for (const [key, value] of Object.entries(obj)) {\n      if (badValues.includes(value)) continue;\n\n      const processedValue = processRecord(value, badValues);\n\n      if (\n        processedValue !== undefined &&\n        !(\n          typeof processedValue === \"object\" &&\n          processedValue !== null &&\n          !Array.isArray(processedValue) &&\n          Object.keys(processedValue).length === 0\n        )\n      ) {\n        result[key] = processedValue;\n      }\n    }\n\n    return result;\n  };\n\n  return Computed(processRecord, $record, $badValues);\n}\n","import {\n  Actual,\n  DestroyContainer,\n  MaybeMessage,\n  Message,\n  MessageType,\n  Value,\n} from \"silentium\";\n\nexport function StateRecord(\n  state$: MessageType,\n  values$: MessageType,\n  sequence: MaybeMessage<unknown[]>,\n) {\n  const dc = DestroyContainer();\n  let stateIndex = -1;\n  let latestState: string | null = null;\n  let result: Record<string, unknown> = {};\n  const sequence$ = Value(Actual(sequence));\n  return Message((resolve, reject) => {\n    dc.add(\n      state$\n        .then((state) => {\n          if (state === sequence$.value?.[stateIndex + 1]) {\n            stateIndex += 1;\n            latestState = state as string;\n          } else {\n            stateIndex = -1;\n            latestState = null;\n            result = {};\n          }\n        })\n        .catch(reject),\n    );\n    dc.add(\n      values$\n        .then((value) => {\n          if (latestState !== null) {\n            result[latestState] = value;\n          }\n          if (stateIndex + 1 === sequence$.value?.length) {\n            resolve(result);\n            stateIndex = -1;\n            latestState = null;\n            result = {};\n          }\n        })\n        .catch(reject),\n    );\n    return () => dc.destroy();\n  });\n}\n","import {\n  Actual,\n  DestroyContainer,\n  MaybeMessage,\n  Message,\n  MessageType,\n} from \"silentium\";\n\n/**\n * Switch between many messages by known value\n */\nexport function Switch<T, K>(\n  _base: MaybeMessage,\n  options: [K | K[], MessageType<T>][],\n) {\n  const $base = Actual(_base);\n  return Message<T>((resolve, reject) => {\n    const dc = DestroyContainer();\n    $base\n      .then((v) => {\n        const msg = options.find((entry) =>\n          Array.isArray(entry[0]) ? entry[0].includes(v as K) : entry[0] === v,\n        );\n        if (msg) {\n          dc.add(msg[1].then(resolve).catch(reject));\n        }\n      })\n      .catch(reject);\n    return dc.destructor;\n  });\n}\n","import { Actual, ExecutorApplied, MaybeMessage, Message } from \"silentium\";\n\n/**\n * Defer a message to the event loop\n * so that it executes once within\n * a certain timer firing interval\n *\n * @url https://silentium.pw/article/task/view\n */\nexport function Task<T>(baseSrc: MaybeMessage<T>, delay: number = 0) {\n  const $base = Actual(baseSrc);\n  return Message<T>(function TaskImpl(r) {\n    let prevTimer: unknown | null = null;\n    ExecutorApplied($base, (fn) => {\n      return (v) => {\n        if (prevTimer) {\n          clearTimeout(prevTimer as number);\n        }\n        prevTimer = setTimeout(() => {\n          fn(v);\n        }, delay);\n      };\n    }).then(r);\n  });\n}\n","import { Message, MessageType } from \"silentium\";\n\n/**\n * Accumulates the last value Of the source and returns one result once per tick\n *\n * @url https://silentium.pw/article/tick/view\n */\nexport function Tick<T>($base: MessageType<T>) {\n  return Message<T>(function TickImpl(r) {\n    let microtaskScheduled = false;\n    let lastValue: T | null = null;\n\n    const scheduleMicrotask = () => {\n      microtaskScheduled = true;\n      queueMicrotask(() => {\n        microtaskScheduled = false;\n        if (lastValue !== null) {\n          r(lastValue);\n          lastValue = null;\n        }\n      });\n    };\n\n    $base.then((v) => {\n      lastValue = v;\n      if (!microtaskScheduled) {\n        scheduleMicrotask();\n      }\n    });\n  });\n}\n","import { Message, MessageType } from \"silentium\";\n\n/**\n * By receiving a message with a key and value, collects a table\n * of all previously received messages in the form of a structure\n * https://silentium-lab.github.io/silentium-components/#/structures/hash-table\n */\nexport function HashTable<T>($base: MessageType<[string, unknown]>) {\n  return Message<T>(function HashTableImpl(r) {\n    const record: Record<string, unknown> = {};\n\n    $base.then(([key, value]) => {\n      record[key] = value;\n      r(record as T);\n    });\n  });\n}\n","import { Actual, All, Message, MessageType } from \"silentium\";\n\ntype UnWrap<T> = T extends MessageType<infer U> ? U : T;\n\n/**\n * Returns record Of data from record Of sources\n * https://silentium-lab.github.io/silentium-components/#/structures/record\n */\nexport function Record<T>(record: Record<string, T>) {\n  return Message<Record<string, UnWrap<T>>>(function RecordImpl(r) {\n    const keys = Object.keys(record);\n    keys.forEach((key) => {\n      record[key] = Actual(record[key]) as any;\n    });\n    All(...(Object.values(record) as any)).then((entries) => {\n      const record: Record<string, any> = {};\n      entries.forEach((entry, index) => {\n        record[keys[index]] = entry;\n      });\n      r(record);\n    });\n  });\n}\n","import {\n  Actual,\n  ConstructorType,\n  MaybeMessage,\n  Message,\n  Of,\n  Once,\n} from \"silentium\";\n\nimport { Record } from \"../structures\";\n\n/**\n * Modify the object structure\n * with the ability to create new fields based on\n * existing ones in the object\n *\n * @url https://silentium.pw/article/transformed/view\n */\nexport function Transformed<T extends Record<string, any>>(\n  _base: MaybeMessage<T>,\n  transformRules: Record<string, ConstructorType<[MaybeMessage<any>]>>,\n) {\n  const $base = Actual(_base);\n  return Message((resolve) => {\n    $base.then((v) => {\n      const existedKeysMap: Record<string, number> = {};\n      const sourceObject = Object.fromEntries(\n        Object.entries(v).map((entry) => {\n          if (transformRules[entry[0]]) {\n            existedKeysMap[entry[0]] = 1;\n            return [entry[0], transformRules[entry[0]](v)];\n          }\n\n          return [entry[0], Of(entry[1])];\n        }),\n      );\n\n      Object.keys(transformRules).forEach((key) => {\n        if (!existedKeysMap[key]) {\n          sourceObject[key] = transformRules[key](v);\n        }\n      });\n      const record = Once(Record(sourceObject));\n      record.then(resolve);\n    });\n  });\n}\n","import { Actual, ConstructorType, Map, MaybeMessage } from \"silentium\";\n\nimport { Transformed } from \"../behaviors/Transformed\";\n\nexport function TransformedList<T extends any[]>(\n  _base: MaybeMessage<T>,\n  transformRules: Record<string, ConstructorType<[MaybeMessage<any>]>>,\n) {\n  return Map(Actual(_base), (v) => Transformed(v, transformRules));\n}\n","import { All, Message, MessageType } from \"silentium\";\n\n/**\n * Logical AND over two messages\n * https://silentium-lab.github.io/silentium-components/#/boolean/and\n */\nexport function And($one: MessageType<boolean>, $two: MessageType<boolean>) {\n  return Message<boolean>(function AndImpl(r) {\n    All($one, $two).then(([one, two]) => {\n      r(!!(one && two));\n    });\n  });\n}\n","import { Applied, Message, MessageType } from \"silentium\";\n\n/**\n * Convert Any source to boolean source\n * https://silentium-lab.github.io/silentium-components/#/boolean/bool\n */\nexport function Bool($base: MessageType) {\n  return Message<boolean>(function BoolImpl(r) {\n    Applied($base, Boolean).then(r);\n  });\n}\n","import { Message, MessageType } from \"silentium\";\n\n/**\n * Logical negation of message\n * https://silentium-lab.github.io/silentium-components/#/boolean/not\n */\nexport function Not($base: MessageType<boolean>) {\n  return Message<boolean>(function NotImpl(r) {\n    $base.then((v) => {\n      r(!v);\n    });\n  });\n}\n","import { All, Message, MessageType } from \"silentium\";\n\n/**\n * Logical OR over two messages\n * https://silentium-lab.github.io/silentium-components/#/boolean/or\n */\nexport function Or($one: MessageType<boolean>, $two: MessageType<boolean>) {\n  return Message<boolean>(function OrImpl(r) {\n    All($one, $two).then(([one, two]) => {\n      r(!!(one || two));\n    });\n  });\n}\n","import { Message, MessageType } from \"silentium\";\n\n/**\n * Represents object from json\n */\nexport function FromJson<T = Record<string, unknown>>(\n  $json: MessageType<string>,\n) {\n  return Message<T>(function FromJsonImpl(resolve, reject) {\n    $json.then((json) => {\n      try {\n        resolve(JSON.parse(json));\n      } catch (e) {\n        reject(new Error(`Failed to parse JSON: ${e}`));\n      }\n    });\n  });\n}\n","import { Message, MessageType } from \"silentium\";\n\n/**\n * Represents json from object\n */\nexport function ToJson($data: MessageType) {\n  return Message<string>(function ToJsonImpl(resolve, reject) {\n    $data.then((data: unknown) => {\n      try {\n        resolve(JSON.stringify(data));\n      } catch {\n        reject(new Error(\"Failed to convert to JSON\"));\n      }\n    });\n  });\n}\n","import { Applied, Message, MessageType } from \"silentium\";\n\n/**\n * Represents the first element Of an array.\n */\nexport function First<T extends Array<unknown>>($base: MessageType<T>) {\n  return Message<T[0]>(function FirstImpl(r) {\n    Applied($base, (a) => a[0]).then(r);\n  });\n}\n","import { Actual, All, MaybeMessage, Message, Of } from \"silentium\";\n\n/**\n * First match Of regexp\n * https://silentium-lab.github.io/silentium-components/#/system/regexp-matched\n */\nexport function RegexpMatch(\n  patternSrc: MaybeMessage<string>,\n  valueSrc: MaybeMessage<string>,\n  flagsSrc: MaybeMessage<string> = Of(\"\"),\n) {\n  const $pattern = Actual(patternSrc);\n  const $value = Actual(valueSrc);\n  const $flags = Actual(flagsSrc);\n  return Message<string[]>(function RegexpMatchImpl(r) {\n    All($pattern, $value, $flags).then(([pattern, value, flags]) => {\n      const result = new RegExp(pattern, flags).exec(value);\n      r(result ?? []);\n    });\n  });\n}\n","import { Actual, All, MaybeMessage, Message, Of } from \"silentium\";\n\n/**\n * Boolean source what checks what string matches pattern\n * https://silentium-lab.github.io/silentium-components/#/system/regexp-matched\n */\nexport function RegexpMatched(\n  patternSrc: MaybeMessage<string>,\n  valueSrc: MaybeMessage<string>,\n  flagsSrc: MaybeMessage<string> = Of(\"\"),\n) {\n  const $pattern = Actual(patternSrc);\n  const $value = Actual(valueSrc);\n  const $flags = Actual(flagsSrc);\n  return Message<boolean>(function RegexpMatchedImpl(r) {\n    All($pattern, $value, $flags).then(([pattern, value, flags]) => {\n      r(new RegExp(pattern, flags).test(value));\n    });\n  });\n}\n","import { Actual, All, Applied, MaybeMessage } from \"silentium\";\n\n/**\n * Returns string replaced by regular expression pattern\n * https://silentium-lab.github.io/silentium-components/#/system/regexp-replaced\n */\nexport function RegexpReplaced(\n  valueSrc: MaybeMessage<string>,\n  patternSrc: MaybeMessage<string>,\n  replaceValueSrc: MaybeMessage<string>,\n  flagsSrc: MaybeMessage<string> = \"\",\n) {\n  const $value = Actual(valueSrc);\n  const $pattern = Actual(patternSrc);\n  const $replaceValue = Actual(replaceValueSrc);\n  const $flags = Actual(flagsSrc);\n  return Applied(\n    All($pattern, $value, $replaceValue, $flags),\n    ([pattern, value, replaceValue, flags]) => {\n      return String(value).replace(new RegExp(pattern, flags), replaceValue);\n    },\n  );\n}\n","import { Actual, All, Message, MessageType } from \"silentium\";\n\n/**\n * Ability to mutate some object, helpful when integrate to procedure systems\n * https://silentium-lab.github.io/silentium-components/#/system/set\n */\nexport function Set<T extends Record<string, unknown>>(\n  baseSrc: MessageType<T>,\n  keySrc: MessageType<string>,\n  valueSrc: MessageType<unknown>,\n) {\n  const $base = Actual(baseSrc);\n  const $key = Actual(keySrc);\n  const $value = Actual(valueSrc);\n  return Message<T>(function SetImpl(r) {\n    All($base, $key, $value).then(([base, key, value]) => {\n      (base as Record<string, unknown>)[key] = value;\n      r(base);\n    });\n  });\n}\n","import {\n  Actual,\n  All,\n  ConstructorType,\n  DestroyableType,\n  DestroyContainer,\n  MaybeMessage,\n  Message,\n  MessageType,\n  Of,\n} from \"silentium\";\n\nimport { RegexpMatched } from \"../system\";\n\nexport interface Route<T> {\n  pattern?: string;\n  patternFlags?: string;\n  condition?: (v: unknown) => boolean;\n  message: ConstructorType<[], MaybeMessage<T>>;\n}\n\n/**\n * Router component what will return template if url matches pattern\n *\n * @url https://silentium.pw/article/router/view\n */\nexport function Router<T = string>(\n  _url: MaybeMessage<string>,\n  routes: MaybeMessage<Route<T>[]>,\n  $default: ConstructorType<[], MaybeMessage<T>>,\n): MessageType<T> & DestroyableType {\n  const $routes = Actual(routes);\n  const $url = Actual(_url);\n  return Message<T>(function RouterImpl(r) {\n    const dc = DestroyContainer();\n    const destructor = () => {\n      dc.destroy();\n    };\n    All($routes, $url).then(([routes, url]) => {\n      destructor();\n      const $matches = All(\n        ...routes.map((r) =>\n          r.pattern\n            ? RegexpMatched(\n                Of(r.pattern),\n                Of(url),\n                r.patternFlags ? Of(r.patternFlags) : undefined,\n              )\n            : r?.condition?.(url),\n        ),\n      );\n      $matches.then((matches) => {\n        const index = matches.findIndex((v) => v === true);\n\n        if (index === -1) {\n          const instance = Actual($default());\n          dc.add(instance);\n          instance.then(r);\n        }\n\n        if (index > -1) {\n          const instance = Actual(routes[index].message());\n          dc.add(instance);\n          instance.then(r);\n        }\n      });\n    });\n    return destructor;\n  });\n}\n","import { All, Message, MessageType, Of } from \"silentium\";\n\n/**\n * Join sources Of strings to one source\n * https://silentium-lab.github.io/silentium-components/#/string/concatenated\n */\nexport function Concatenated(\n  sources: MessageType<string>[],\n  joinPartSrc: MessageType<string> = Of(\"\"),\n) {\n  return Message<string>(function ConcatenatedImpl(r) {\n    All(joinPartSrc, ...sources).then(([joinPart, ...strings]) => {\n      r(strings.join(joinPart));\n    });\n  });\n}\n","import {\n  Actual,\n  All,\n  Applied,\n  ConstructorType,\n  DestroyableType,\n  DestroyContainer,\n  isDestroyable,\n  isMessage,\n  Late,\n  MaybeMessage,\n  Message,\n  MessageType,\n  Of,\n  Rejections,\n} from \"silentium\";\n\nimport { Record } from \"../structures\";\n\n/**\n * Allows creating a string template with\n * variables inserted into it; when variables change,\n * the template value will change\n *\n * @url https://silentium.pw/article/template/view\n */\nexport function Template(\n  src: MaybeMessage<string> | ((t: TemplateImpl) => string) = \"\",\n  $places: MaybeMessage<Record<string, unknown>> = Of({}),\n) {\n  const $src = Late<string>();\n  if (typeof src === \"string\" || isMessage(src)) {\n    $src.chain(Actual(src));\n  }\n\n  const t = new TemplateImpl($src, $places ? Actual($places) : undefined);\n\n  if (typeof src === \"function\") {\n    $src.chain(\n      Message((r) => {\n        r(src(t));\n      }),\n    );\n  }\n\n  return t;\n}\n\nexport class TemplateImpl implements MessageType<string>, DestroyableType {\n  private dc = DestroyContainer();\n  private rejections = Rejections();\n  private vars: Record<string, MessageType> = {\n    $TPL: Of(\"$TPL\"),\n  };\n\n  public constructor(\n    private $src: MessageType<string> = Of(\"\"),\n    private $places: MessageType<Record<string, unknown>> = Of({}),\n    private escapeFn = escaped,\n  ) {}\n\n  public then(transport: ConstructorType<[string]>): this {\n    const $vars = Record(this.vars);\n    Applied(All(this.$src, this.$places, $vars), ([base, rules, vars]) => {\n      try {\n        Object.entries(rules).forEach(([ph, val]) => {\n          base = base.replaceAll(ph, String(val));\n        });\n        Object.entries(vars).forEach(([ph, val]) => {\n          base = base.replaceAll(ph, String(val));\n        });\n      } catch (e) {\n        this.rejections.reject(e);\n      }\n\n      return base;\n    }).then(transport);\n    return this;\n  }\n\n  public template(value: string) {\n    this.$src = Of(value);\n  }\n\n  /**\n   * Register raw unsafe variable\n   */\n  public raw(src: MessageType<unknown>) {\n    const hash =\n      Date.now().toString(36) + Math.random().toString(36).substring(2);\n    const varName = `$var${hash}`;\n    if (isDestroyable(src)) {\n      this.dc.add(src);\n    }\n    this.vars[varName] = src;\n    return varName;\n  }\n\n  /**\n   * Register variable what will be safe in HTML by default\n   * or with your custom escape logic\n   */\n  public escaped(src: MessageType<any>) {\n    if (isDestroyable(src)) {\n      this.dc.add(src);\n    }\n    return this.raw(Applied(src, this.escapeFn));\n  }\n\n  public catch(rejected: ConstructorType<[unknown]>): this {\n    this.rejections.catch(rejected);\n    return this;\n  }\n\n  public destroy(): this {\n    this.dc.destroy();\n    return this;\n  }\n}\n\nconst escapeMap = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#x27;\",\n  \"/\": \"&#x2F;\",\n} as const;\n\n/**\n * String with html escaped\n */\nexport function escaped(base: string) {\n  if (typeof base !== \"string\") {\n    base = String(base);\n  }\n  return base.replace(\n    /[&<>\"'/]/g,\n    (match) => escapeMap[match as keyof typeof escapeMap],\n  );\n}\n"],"names":["Branch","_condition","_left","_right","$condition","Actual","$left","$right","Message","r","left","Primitive","right","then","v","Error","result","primitive","BranchLazy","dc","DestroyContainer","destructor","destroy","instance","add","Constant","permanent","$trigger","resolve","reject","catch","ResetSilenceCache","Deadline","$base","_timeout","$timeout","timer","base","Shared","timeout","clearTimeout","timeoutReached","setTimeout","Filtered","Deferred","value","isFilled","Detached","Dirty","keep","exclude","cloner","$comparing","Late","JSON","parse","stringify","Source","$comparingClone","Applied","All","comparing","Object","fromEntries","entries","filter","key","includes","use","Loading","$start","$finish","Lock","$lock","locked","newLock","Memo","last","MergeAccumulation","$reset","accumulation","lastAccumulated","nextValue","mergeWith","value1","value2","Array","isArray","concat","resetValue","target","source","customizer","keys","forEach","srcValue","objValue","isObject","OnlyChanged","first","Part","defaultValue","$baseShared","$keyedShared","keyed","split","primitiveWithException","NotSet","Symbol","Path","_base","_keyed","def","$keyed","$def","d","Polling","RecordTruncated","_record","_badValues","$record","$badValues","processRecord","obj","badValues","processedValue","length","Computed","StateRecord","state$","values$","sequence","stateIndex","latestState","sequence$","Value","state","Switch","options","msg","find","entry","Task","baseSrc","delay","prevTimer","ExecutorApplied","fn","Tick","microtaskScheduled","lastValue","queueMicrotask","HashTable","record","Record","values","index","Transformed","transformRules","existedKeysMap","sourceObject","map","Of","Once","TransformedList","Map","And","$one","$two","one","two","Bool","Boolean","Not","Or","FromJson","$json","json","e","ToJson","$data","data","First","a","RegexpMatch","patternSrc","valueSrc","flagsSrc","$pattern","$value","$flags","pattern","flags","RegExp","exec","RegexpMatched","test","RegexpReplaced","replaceValueSrc","$replaceValue","replaceValue","String","replace","Set","keySrc","$key","Router","_url","routes","$default","$routes","$url","url","patternFlags","condition","matches","findIndex","message","Concatenated","sources","joinPartSrc","joinPart","strings","join","Template","src","$places","$src","isMessage","chain","t","TemplateImpl","constructor","escapeFn","escaped","this","__publicField","Rejections","$TPL","transport","$vars","vars","rules","ph","val","replaceAll","rejections","template","raw","varName","Date","now","toString","Math","random","substring","isDestroyable","rejected","escapeMap","match"],"mappings":"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"}