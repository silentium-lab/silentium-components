{"version":3,"file":"silentium-components.min.mjs","sources":["../src/behaviors/Dirty.ts","../src/behaviors/Loading.ts","../src/behaviors/Path.ts","../src/behaviors/Deadline.ts","../src/behaviors/Tick.ts","../src/behaviors/Sync.ts","../src/behaviors/Deferred.ts","../src/behaviors/Branch.ts","../src/behaviors/Memo.ts","../src/behaviors/Lock.ts","../src/behaviors/Shot.ts","../src/behaviors/OnlyChanged.ts","../src/structures/HashTable.ts","../src/structures/Record.ts","../src/strings/Concatenated.ts","../src/system/RegexpMatched.ts","../src/navigation/Router.ts","../src/system/RegexpReplaced.ts","../src/system/RegexpMatch.ts","../src/system/Set.ts","../src/boolean/And.ts","../src/boolean/Or.ts","../src/boolean/Not.ts","../src/formats/FromJson.ts","../src/formats/ToJson.ts","../src/lists/First.ts"],"sourcesContent":["import { all, applied, InformationType, of } from \"silentium\";\n\n/**\n * Takes source and remember it first value\n * returns new record, what will contain only fields what was changed\n * https://silentium-lab.github.io/silentium-components/#/behaviors/dirty\n */\nexport const dirty = <T extends object>(\n  baseEntitySource: InformationType<T>,\n  alwaysKeep: string[] = [],\n  excludeKeys: string[] = [],\n) => {\n  const [comparing, co] = of<T>();\n\n  const comparingDetached = applied(comparing, (value) =>\n    JSON.parse(JSON.stringify(value)),\n  );\n\n  const i: InformationType<Partial<T>> = (o) => {\n    all(\n      comparingDetached,\n      baseEntitySource,\n    )(([comparing, base]) => {\n      if (!comparing) {\n        return;\n      }\n\n      o(\n        Object.fromEntries(\n          Object.entries(comparing).filter(([key, value]) => {\n            if (alwaysKeep.includes(key)) {\n              return true;\n            }\n            if (excludeKeys.includes(key)) {\n              return false;\n            }\n            return value !== (base as any)[key];\n          }),\n        ) as T,\n      );\n    });\n  };\n\n  return [i, co] as const;\n};\n","import { InformationType } from \"silentium\";\n\n/**\n * Representation of loading process\n * first informatin source begins loading\n * second information source stops loading\n * https://silentium-lab.github.io/silentium-components/#/behaviors/loading\n */\nexport const loading = (\n  loadingStartSource: InformationType<unknown>,\n  loadingFinishSource: InformationType<unknown>,\n): InformationType<boolean> => {\n  return (o) => {\n    loadingStartSource(() => {\n      o(true);\n    });\n\n    loadingFinishSource(() => {\n      o(false);\n    });\n  };\n};\n","import { all, InformationType } from \"silentium\";\n\n/**\n * Return source of record path\n * https://silentium-lab.github.io/silentium-components/#/behaviors/path\n */\nexport const path = <\n  R,\n  T extends Record<string, unknown> | Array<unknown> = any,\n  K extends string = any,\n>(\n  baseSrc: InformationType<T>,\n  keySrc: InformationType<K>,\n): InformationType<R> => {\n  return (o) => {\n    all(\n      baseSrc,\n      keySrc,\n    )(([base, key]) => {\n      const keyChunks = key.split(\".\");\n      let value: unknown = base;\n      keyChunks.forEach((keyChunk) => {\n        value = (value as Record<string, unknown>)[keyChunk];\n      });\n\n      if (value !== undefined && value !== base) {\n        o(value as R);\n      }\n    });\n  };\n};\n","import {\n  filtered,\n  InformationType,\n  OwnerType,\n  sharedStateless,\n} from \"silentium\";\n\n/**\n * https://silentium-lab.github.io/silentium-components/#/behaviors/path\n */\nexport const deadline = <T>(\n  error: OwnerType<Error>,\n  baseSrc: InformationType<T>,\n  timeoutSrc: InformationType<number>,\n): InformationType<T> => {\n  let timerHead: unknown = null;\n  return (o) => {\n    const [baseShared, pool] = sharedStateless(baseSrc);\n\n    timeoutSrc((timeout) => {\n      if (timerHead) {\n        clearTimeout(timerHead as number);\n      }\n      let timeoutReached = false;\n\n      timerHead = setTimeout(() => {\n        if (timeoutReached) {\n          return;\n        }\n        timeoutReached = true;\n        error(new Error(\"Timeout reached in Deadline class\"));\n      }, timeout);\n\n      const f = filtered(baseShared, () => !timeoutReached);\n      f(o);\n\n      baseShared(() => {\n        timeoutReached = true;\n      });\n    });\n\n    return () => {\n      pool.destroy();\n    };\n  };\n};\n","import { InformationType } from \"silentium\";\n\n/**\n * Accumulates the last value of the source and returns one result once per tick\n * https://silentium-lab.github.io/silentium-components/#/behaviors/tick\n */\nexport const tick = <T>(baseSrc: InformationType<T>): InformationType<T> => {\n  return (o) => {\n    let microtaskScheduled = false;\n    let lastValue: T | null = null;\n\n    const scheduleMicrotask = () => {\n      microtaskScheduled = true;\n      queueMicrotask(() => {\n        microtaskScheduled = false;\n        if (lastValue !== null) {\n          o(lastValue);\n          lastValue = null;\n        }\n      });\n    };\n\n    baseSrc((v) => {\n      lastValue = v;\n      if (!microtaskScheduled) {\n        scheduleMicrotask();\n      }\n    });\n  };\n};\n","import { InformationType } from \"silentium\";\n\nexport const sync = <T>(base: InformationType<T>) => {\n  let value: T | undefined;\n\n  base((v) => {\n    value = v;\n  });\n\n  return {\n    value() {\n      if (value === undefined) {\n        throw new Error(\"no value in sync\");\n      }\n\n      return value;\n    },\n  };\n};\n","import { InformationType, isFilled } from \"silentium\";\nimport { sync } from \"./Sync\";\n\n/**\n * Defer one source after another, gives values of baseSrc only once when triggerSrc responds\n * https://silentium-lab.github.io/silentium-components/#/behaviors/deferred\n */\nexport const deferred = <T>(\n  baseSrc: InformationType<T>,\n  triggerSrc: InformationType<unknown>,\n): InformationType<T> => {\n  return (o) => {\n    const baseSync = sync(baseSrc);\n\n    triggerSrc(() => {\n      if (isFilled(baseSync.value())) {\n        o(baseSync.value());\n      }\n    });\n  };\n};\n","import { InformationType } from \"silentium\";\nimport { sync } from \"./Sync\";\n\n/**\n * https://silentium-lab.github.io/silentium-components/#/behaviors/branch\n */\nexport const branch = <Then, Else>(\n  condition: InformationType<boolean>,\n  left: InformationType<Then>,\n  right?: InformationType<Else>,\n): InformationType<Then | Else> => {\n  return (o) => {\n    const leftSync = sync(left);\n    let rightSync: { value: () => Else };\n\n    if (right !== undefined) {\n      rightSync = sync(right);\n    }\n\n    condition((v) => {\n      if (v) {\n        o(leftSync.value());\n      } else if (rightSync) {\n        o(rightSync.value());\n      }\n    });\n  };\n};\n","import { InformationType } from \"silentium\";\n\n/**\n * Didn't respond if new value of baseSrc equals to old value\n * https://silentium-lab.github.io/silentium-components/#/behaviors/memo\n */\nexport const memo = <T>(baseSrc: InformationType<T>): InformationType<T> => {\n  let lastValue: T | null = null;\n\n  return (o) => {\n    baseSrc((v) => {\n      if (v !== lastValue) {\n        o(v);\n        lastValue = v;\n      }\n    });\n  };\n};\n","import { filtered, InformationType } from \"silentium\";\n\n/**\n * https://silentium-lab.github.io/silentium-components/#/behaviors/lock\n */\nexport const lock = <T>(\n  baseSrc: InformationType<T>,\n  lockSrc: InformationType<boolean>,\n): InformationType<T> => {\n  let locked = false;\n  const i = filtered(baseSrc, () => !locked);\n\n  return (o) => {\n    lockSrc((newLock) => {\n      locked = newLock;\n    });\n    i(o);\n  };\n};\n","import { InformationType, isFilled } from \"silentium\";\nimport { sync } from \"./Sync\";\n\n/**\n * Helps to represent only last fresh value of some source, refreshing controls by shotSrc\n * https://silentium-lab.github.io/silentium-components/#/behaviors/shot\n */\nexport const shot = <T>(\n  targetSrc: InformationType<T>,\n  triggerSrc: InformationType,\n): InformationType<T> => {\n  return (o) => {\n    const targetSync = sync(targetSrc);\n\n    triggerSrc(() => {\n      if (isFilled(targetSync.value())) {\n        o(targetSync.value());\n      }\n    });\n  };\n};\n","import { InformationType } from \"silentium\";\n\n/**\n * Represents source what was changed at least once\n * https://silentium-lab.github.io/silentium-components/#/behaviors/only-changed\n */\nexport const onlyChanged = <T>(\n  baseSrc: InformationType<T>,\n): InformationType<T> => {\n  let firstValue = false;\n  return (o) => {\n    baseSrc((v) => {\n      if (firstValue === false) {\n        firstValue = true;\n      } else {\n        o(v);\n      }\n    });\n  };\n};\n","import { InformationType } from \"silentium\";\n\n/**\n * https://silentium-lab.github.io/silentium-components/#/structures/hash-table\n */\nexport const hashTable = <T>(\n  base: InformationType<[string, unknown]>,\n): InformationType<T> => {\n  return (o) => {\n    const record: Record<string, unknown> = {};\n\n    base(([key, value]) => {\n      record[key] = value;\n      o(record as T);\n    });\n  };\n};\n","import { all, InformationType } from \"silentium\";\n\ntype UnInformation<T> = T extends InformationType<infer U> ? U : never;\n\n/**\n * Returns record of data from record of sources\n * https://silentium-lab.github.io/silentium-components/#/structures/record\n */\nexport const record = <T extends InformationType>(\n  recordSrc: Record<string, T>,\n): InformationType<Record<string, UnInformation<T>>> => {\n  return (o) => {\n    const keys = Object.keys(recordSrc);\n    all(...Object.values(recordSrc))((entries) => {\n      const record: Record<string, any> = {};\n      entries.forEach((entry, index) => {\n        record[keys[index]] = entry;\n      });\n      o(record);\n    });\n  };\n};\n","import { all, i, InformationType } from \"silentium\";\n\n/**\n * Join sources of strings to one source\n * https://silentium-lab.github.io/silentium-components/#/string/concatenated\n */\nexport const concatenated = (\n  sources: InformationType<string>[],\n  joinPartSrc: InformationType<string> = i(\"\"),\n): InformationType<string> => {\n  return (o) => {\n    all(\n      joinPartSrc,\n      ...sources,\n    )(([joinPart, ...strings]) => {\n      o(strings.join(joinPart));\n    });\n  };\n};\n","import { all, i, InformationType } from \"silentium\";\n\n/**\n * Boolean source what checks what string matches pattern\n * https://silentium-lab.github.io/silentium-components/#/system/regexp-matched\n */\nexport const regexpMatched =\n  (\n    patternSrc: InformationType<string>,\n    valueSrc: InformationType<string>,\n    flagsSrc: InformationType<string> = i(\"\"),\n  ): InformationType<boolean> =>\n  (o) => {\n    all(\n      patternSrc,\n      valueSrc,\n      flagsSrc,\n    )(([pattern, value, flags]) => {\n      o(new RegExp(pattern, flags).test(value));\n    });\n  };\n","import { any, chain, i, InformationType, OwnerType } from \"silentium\";\nimport { branch } from \"../behaviors\";\nimport { regexpMatched } from \"../system/RegexpMatched\";\n\nexport interface Route<T> {\n  pattern: string;\n  patternFlags?: string;\n  template: T | InformationType<T>;\n}\n\n/**\n * Router component what will return template if url matches pattern\n * https://silentium-lab.github.io/silentium-components/#/navigation/router\n */\nexport const router = <T = \"string\">(\n  urlSrc: InformationType<string>,\n  routesSrc: InformationType<Route<T>[]>,\n  defaultSrc: InformationType<T>,\n): InformationType<T> => {\n  return (o) => {\n    routesSrc((routes) => {\n      any(\n        chain(urlSrc, defaultSrc),\n        ...routes.map((r) => {\n          return branch(\n            regexpMatched(\n              i(r.pattern),\n              urlSrc,\n              r.patternFlags ? i(r.patternFlags) : undefined,\n            ),\n            (typeof r.template === \"function\"\n              ? r.template\n              : i(r.template)) as InformationType,\n          );\n        }),\n      )(o as OwnerType<unknown>);\n    });\n  };\n};\n","import { all, i, InformationType } from \"silentium\";\n\n/**\n * Returns string replaced by regular expression pattern\n * https://silentium-lab.github.io/silentium-components/#/system/regexp-replaced\n */\nexport const regexpReplaced =\n  (\n    valueSrc: InformationType<string>,\n    patternSrc: InformationType<string>,\n    replaceValueSrc: InformationType<string>,\n    flagsSrc: InformationType<string> = i(\"\"),\n  ): InformationType<string> =>\n  (o) => {\n    all(\n      patternSrc,\n      valueSrc,\n      replaceValueSrc,\n      flagsSrc,\n    )(([pattern, value, replaceValue, flags]) => {\n      o(String(value).replace(new RegExp(pattern, flags), replaceValue));\n    });\n  };\n","import { all, i, InformationType } from \"silentium\";\n\n/**\n * First match of regexp\n * https://silentium-lab.github.io/silentium-components/#/system/regexp-matched\n */\nexport const regexpMatch =\n  (\n    patternSrc: InformationType<string>,\n    valueSrc: InformationType<string>,\n    flagsSrc: InformationType<string> = i(\"\"),\n  ): InformationType<string[]> =>\n  (o) => {\n    all(\n      patternSrc,\n      valueSrc,\n      flagsSrc,\n    )(([pattern, value, flags]) => {\n      const result = new RegExp(pattern, flags).exec(value);\n      o(result ?? []);\n    });\n  };\n","import { all, InformationType } from \"silentium\";\n\n/**\n * Ability to mutate some object, helpful when integrate to procedure systems\n * https://silentium-lab.github.io/silentium-components/#/system/set\n */\nexport const set = <T extends Record<string, unknown>>(\n  baseSrc: InformationType<T>,\n  keySrc: InformationType<string>,\n  valueSrc: InformationType<unknown>,\n): InformationType<T> => {\n  return (o) => {\n    all(\n      baseSrc,\n      keySrc,\n      valueSrc,\n    )(([base, key, value]) => {\n      (base as Record<string, unknown>)[key] = value;\n      o(base);\n    });\n  };\n};\n","import { all, InformationType } from \"silentium\";\n\n/**\n * https://silentium-lab.github.io/silentium-components/#/boolean/and\n */\nexport const and = (\n  oneSrc: InformationType<boolean>,\n  twoSrc: InformationType<boolean>,\n): InformationType<boolean> => {\n  return (o) => {\n    all(\n      oneSrc,\n      twoSrc,\n    )(([one, two]) => {\n      o(one && two);\n    });\n  };\n};\n","import { all, InformationType } from \"silentium\";\n\n/**\n * https://silentium-lab.github.io/silentium-components/#/boolean/or\n */\nexport const or = (\n  oneSrc: InformationType<boolean>,\n  twoSrc: InformationType<boolean>,\n): InformationType<boolean> => {\n  return (o) => {\n    all(\n      oneSrc,\n      twoSrc,\n    )(([one, two]) => {\n      o(one || two);\n    });\n  };\n};\n","import { InformationType } from \"silentium\";\n\n/**\n * https://silentium-lab.github.io/silentium-components/#/boolean/not\n */\nexport const not = (\n  baseSrc: InformationType<boolean>,\n): InformationType<boolean> => {\n  return (o) => {\n    baseSrc((v) => {\n      o(!v);\n    });\n  };\n};\n","import { InformationType, OwnerType } from \"silentium\";\n\n/**\n * Represents object from json\n */\nexport const fromJson = <T>(\n  jsonSrc: InformationType<string>,\n  errorOwner?: OwnerType,\n): InformationType<T> => {\n  return (o) => {\n    jsonSrc((json) => {\n      try {\n        o(JSON.parse(json));\n      } catch (error) {\n        errorOwner?.(new Error(`Failed to parse JSON: ${error}`));\n      }\n    });\n  };\n};\n","import { InformationType, OwnerType } from \"silentium\";\n\n/**\n * Repreresents json from object\n */\nexport const toJson = (\n  dataSrc: InformationType,\n  errorOwner?: OwnerType,\n): InformationType<string> => {\n  return (o) => {\n    dataSrc((data) => {\n      try {\n        o(JSON.stringify(data));\n      } catch {\n        errorOwner?.(new Error(\"Failed to convert to JSON\"));\n      }\n    });\n  };\n};\n","import { applied, InformationType } from \"silentium\";\n\n/**\n * Represents the first element of an array.\n */\nexport const first = <T extends Array<unknown>>(\n  baseSrc: InformationType<T>,\n): InformationType<T[0]> => {\n  return applied(baseSrc, (a) => a[0]);\n};\n"],"names":["dirty","baseEntitySource","alwaysKeep","excludeKeys","comparing","co","of","comparingDetached","applied","value","JSON","parse","stringify","o","all","base","Object","fromEntries","entries","filter","key","includes","loading","loadingStartSource","loadingFinishSource","path","baseSrc","keySrc","keyChunks","split","forEach","keyChunk","deadline","error","timeoutSrc","timerHead","baseShared","pool","sharedStateless","timeout","clearTimeout","timeoutReached","setTimeout","Error","filtered","f","destroy","tick","microtaskScheduled","lastValue","v","queueMicrotask","sync","deferred","triggerSrc","baseSync","isFilled","branch","condition","left","right","leftSync","rightSync","memo","lock","lockSrc","locked","i","newLock","shot","targetSrc","targetSync","onlyChanged","firstValue","hashTable","record","recordSrc","keys","values","entry","index","concatenated","sources","joinPartSrc","joinPart","strings","join","regexpMatched","patternSrc","valueSrc","flagsSrc","pattern","flags","RegExp","test","router","urlSrc","routesSrc","defaultSrc","routes","any","chain","map","r","patternFlags","template","regexpReplaced","replaceValueSrc","replaceValue","String","replace","regexpMatch","result","exec","set","and","oneSrc","twoSrc","one","two","or","not","fromJson","jsonSrc","errorOwner","json","toJson","dataSrc","data","first","a"],"mappings":"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"}