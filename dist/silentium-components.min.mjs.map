{"version":3,"file":"silentium-components.min.mjs","sources":["../src/behaviors/Branch.ts","../src/behaviors/BranchLazy.ts","../src/behaviors/Const.ts","../src/behaviors/Deadline.ts","../src/behaviors/Deferred.ts","../src/behaviors/Detached.ts","../src/behaviors/Dirty.ts","../src/behaviors/Loading.ts","../src/behaviors/Lock.ts","../src/behaviors/Memo.ts","../src/behaviors/OnlyChanged.ts","../src/behaviors/Part.ts","../src/behaviors/Path.ts","../src/behaviors/Polling.ts","../src/behaviors/Shot.ts","../src/behaviors/Task.ts","../src/behaviors/Tick.ts","../src/behaviors/Transaction.ts","../src/structures/HashTable.ts","../src/structures/Record.ts","../src/strings/Concatenated.ts","../src/strings/Template.ts","../src/system/RegexpMatched.ts","../src/system/RegexpReplaced.ts","../src/system/RegexpMatch.ts","../src/system/Set.ts","../src/navigation/Router.ts","../src/boolean/And.ts","../src/boolean/Or.ts","../src/boolean/Not.ts","../src/boolean/Bool.ts","../src/formats/FromJson.ts","../src/formats/ToJson.ts","../src/lists/First.ts"],"sourcesContent":["import {\n  ActualMessage,\n  MaybeMessage,\n  Message,\n  Primitive,\n  Tap,\n} from \"silentium\";\n\n/**\n * Allows switching between left and right messages depending on condition\n * https://silentium-lab.github.io/silentium-components/#/behaviors/branch\n */\nexport function Branch<Then, Else>(\n  _condition: MaybeMessage<boolean>,\n  _left: MaybeMessage<Then>,\n  _right?: MaybeMessage<Else>,\n) {\n  const $condition = ActualMessage(_condition);\n  const $left = ActualMessage(_left);\n  const $right = _right && ActualMessage(_right);\n  return Message<Then | Else>(function () {\n    const left = Primitive($left);\n    let right: ReturnType<typeof Primitive<Else>>;\n    if ($right !== undefined) {\n      right = Primitive($right);\n    }\n    $condition.pipe(\n      Tap((v) => {\n        let result: Then | Else | null = null;\n        if (v) {\n          result = left.primitive();\n        } else if (right) {\n          result = right.primitive();\n        }\n        if (result !== null) {\n          this.use(result);\n        }\n      }),\n    );\n  });\n}\n","import {\n  DestroyableType,\n  DestroyContainer,\n  Message,\n  MessageType,\n  Tap,\n  TapType,\n} from \"silentium\";\n\n/**\n * Depending on the $condition message,\n * creates a new left or right message.\n * When condition changes, old messages are destroyed\n * and new ones are created.\n */\nexport function BranchLazy<Then, Else>(\n  $condition: MessageType<boolean>,\n  $left: TapType<void, MessageType<Then>>,\n  $right?: TapType<void, MessageType<Else>>,\n): MessageType<Then | Else> & DestroyableType {\n  return Message(function () {\n    const dc = DestroyContainer();\n    const destructor = () => {\n      dc.destroy();\n    };\n    $condition.pipe(\n      Tap((v) => {\n        destructor();\n        let instance: MessageType<Then | Else> | undefined;\n        if (v) {\n          instance = $left.use();\n        } else if ($right) {\n          instance = $right.use();\n        }\n        if (instance !== undefined) {\n          instance.pipe(this);\n          dc.add(instance);\n        }\n      }),\n    );\n    return destructor;\n  });\n}\n","import { Message, MessageType, Tap } from \"silentium\";\n\n/**\n * Constant value that will be\n * returned on each value from\n * the $trigger message\n */\nexport function Constant<T>(\n  permanent: T,\n  $trigger: MessageType,\n): MessageType<T> {\n  return Message(function () {\n    $trigger.pipe(\n      Tap(() => {\n        this.use(permanent);\n      }),\n    );\n  });\n}\n","import {\n  ActualMessage,\n  Filtered,\n  MaybeMessage,\n  Message,\n  MessageType,\n  Shared,\n  Tap,\n  TapType,\n} from \"silentium\";\n\n/**\n * Will return an error via error transport if\n * time runs out from $timeout; if $base manages to\n * respond before $timeout then the value from base will be returned\n */\nexport function Deadline<T>(\n  error: TapType<Error>,\n  $base: MessageType<T>,\n  _timeout: MaybeMessage<number>,\n) {\n  const $timeout = ActualMessage(_timeout);\n  return Message<T>(function () {\n    let timer: ReturnType<typeof setTimeout> | number = 0;\n    const base = Shared($base, true);\n    $timeout.pipe(\n      Tap((timeout) => {\n        if (timer) {\n          clearTimeout(timer);\n        }\n        let timeoutReached = false;\n\n        timer = setTimeout(() => {\n          if (timeoutReached) {\n            return;\n          }\n          timeoutReached = true;\n          error.use(new Error(\"Timeout reached in Deadline\"));\n        }, timeout);\n\n        const f = Filtered(base, () => !timeoutReached);\n        f.pipe(this);\n\n        base.pipe(\n          Tap(() => {\n            timeoutReached = true;\n          }),\n        );\n      }),\n    );\n  });\n}\n","import { isFilled, Message, MessageType, Primitive, Tap } from \"silentium\";\n\n/**\n * Defer one source after another, gives values Of baseSrc only when triggerSrc responds\n * https://silentium-lab.github.io/silentium-components/#/behaviors/deferred\n */\nexport function Deferred<T>(\n  $base: MessageType<T>,\n  $trigger: MessageType<unknown>,\n) {\n  return Message(function () {\n    const base = Primitive($base);\n    $trigger.pipe(\n      Tap(() => {\n        const value = base.primitive();\n        if (isFilled(value)) {\n          this.use(value);\n        }\n      }),\n    );\n  });\n}\n","import { isFilled, Message, MessageType, Primitive } from \"silentium\";\n\n/**\n * Message separate from the base\n * allows to take one value from the base\n * but not react to new values of the base message\n */\nexport function Detached<T>($base: MessageType<T>): MessageType<T> {\n  return Message(function () {\n    const v = Primitive($base).primitive();\n    if (isFilled(v)) {\n      this.use(v);\n    }\n  });\n}\n","import {\n  All,\n  Applied,\n  Late,\n  MessageType,\n  SourceType,\n  Tap,\n  TapType,\n} from \"silentium\";\n\n/**\n * Takes source and remember it first value\n * returns new record, what will contain only fields what was changed\n * https://silentium-lab.github.io/silentium-components/#/behaviors/dirty\n */\nexport function Dirty<T>(\n  $base: MessageType<T>,\n  keep: string[] = [],\n  exclude: string[] = [],\n  cloner?: (v: T) => T,\n): SourceType<T> {\n  return new DirtySource($base, keep, exclude, cloner);\n}\n\nclass DirtySource<T> implements SourceType<T> {\n  private $comparing = Late<T>();\n  private cloner: (v: T) => T;\n\n  public constructor(\n    private $base: MessageType<T>,\n    private keep: string[] = [],\n    private exclude: string[] = [],\n    cloner?: (v: T) => T,\n  ) {\n    if (cloner === undefined) {\n      this.cloner = (value) => JSON.parse(JSON.stringify(value));\n    } else {\n      this.cloner = cloner;\n    }\n  }\n\n  public pipe(transport: TapType<T>) {\n    const $comparing = Applied(this.$comparing, this.cloner);\n    All($comparing, this.$base).pipe(\n      Tap(([comparing, base]) => {\n        if (!comparing) {\n          return;\n        }\n        transport.use(\n          Object.fromEntries(\n            Object.entries(comparing).filter(([key, value]) => {\n              if (this.keep.includes(key)) {\n                return true;\n              }\n              if (this.exclude.includes(key)) {\n                return false;\n              }\n              return value !== (base as Record<string, unknown>)[key];\n            }),\n          ) as T,\n        );\n      }),\n    );\n    return this;\n  }\n\n  public use(v: T) {\n    this.$comparing.use(v);\n    return this;\n  }\n}\n","import { Message, MessageType, Tap } from \"silentium\";\n\n/**\n * Representation Of loading process\n * first message begins loading\n * second message stops loading\n * https://silentium-lab.github.io/silentium-components/#/behaviors/loading\n */\nexport function Loading(\n  $start: MessageType<unknown>,\n  $finish: MessageType<unknown>,\n) {\n  return Message<boolean>(function () {\n    $start.pipe(Tap(() => this.use(true)));\n    $finish.pipe(Tap(() => this.use(false)));\n  });\n}\n","import { Filtered, Message, MessageType, Tap } from \"silentium\";\n\n/**\n * Allows locking messages\n * if a $lock message arrives\n * https://silentium-lab.github.io/silentium-components/#/behaviors/lock\n */\nexport function Lock<T>($base: MessageType<T>, $lock: MessageType<boolean>) {\n  return Message<T>(function () {\n    let locked = false;\n    $lock.pipe(\n      Tap((newLock) => {\n        locked = newLock;\n      }),\n    );\n    const i = Filtered($base, () => !locked);\n    i.pipe(this);\n  });\n}\n","import { isFilled, Message, MessageType, Tap } from \"silentium\";\n\n/**\n * Didn't respond if new value Of baseSrc equals to old value\n * https://silentium-lab.github.io/silentium-components/#/behaviors/memo\n */\nexport function Memo<T>($base: MessageType<T>) {\n  return Message<T>(function () {\n    let last: T | null = null;\n    $base.pipe(\n      Tap((v) => {\n        if (v !== last && isFilled(v)) {\n          this.use(v);\n          last = v;\n        }\n      }),\n    );\n  });\n}\n","import { Message, MessageType, Tap } from \"silentium\";\n\n/**\n * Represents source what was changed at least once\n * https://silentium-lab.github.io/silentium-components/#/behaviors/only-changed\n */\nexport function OnlyChanged<T>($base: MessageType<T>) {\n  return Message<T>(function () {\n    let first = false;\n    $base.pipe(\n      Tap((v) => {\n        if (first === false) {\n          first = true;\n        } else {\n          this.use(v);\n        }\n      }),\n    );\n  });\n}\n","import {\n  ActualMessage,\n  All,\n  isFilled,\n  MaybeMessage,\n  MessageType,\n  Primitive,\n  Shared,\n  SharedSource,\n  SourceType,\n  Tap,\n  TapType,\n} from \"silentium\";\n\n/**\n * Return source Of record path\n * https://silentium-lab.github.io/silentium-components/#/behaviors/path\n */\nexport function Part<\n  R,\n  T extends object | Array<any> = any,\n  K extends string = any,\n>($base: SourceType<T>, $key: MaybeMessage<K>): SourceType<R> {\n  return new PartImpl($base, ActualMessage($key));\n}\n\nclass PartImpl<R, T extends object | Array<any>, K extends string = any>\n  implements SourceType<R>\n{\n  private $base: SourceType<T>;\n  private $keyed: MessageType<K>;\n\n  public constructor($base: SourceType<T>, $key: MessageType<K>) {\n    this.$base = SharedSource($base);\n    this.$keyed = Shared($key);\n  }\n\n  public pipe(transport: TapType<R, null>): this {\n    All(this.$base, this.$keyed).pipe(\n      Tap(([base, keyed]) => {\n        const keys = keyed.split(\".\");\n        let value: unknown = base;\n        keys.forEach((key) => {\n          value = (value as Record<string, unknown>)[key];\n        });\n        if (value !== undefined && value !== base) {\n          transport.use(value as R);\n        }\n      }),\n    );\n    return this;\n  }\n\n  public use(value: R): this {\n    const key = Primitive(this.$keyed);\n    if (isFilled(key)) {\n      const base = Primitive(this.$base);\n      this.$base.use({\n        ...base.primitiveWithException(),\n        [key.primitiveWithException()]: value,\n      } as T);\n    }\n    return this;\n  }\n}\n","import {\n  ActualMessage,\n  All,\n  MaybeMessage,\n  Message,\n  MessageType,\n  Tap,\n} from \"silentium\";\n\n/**\n * Return source Of record path\n * https://silentium-lab.github.io/silentium-components/#/behaviors/path\n */\nexport function Path<\n  R,\n  T extends object | Array<any> = any,\n  K extends string = any,\n>($base: MessageType<T>, _keyed: MaybeMessage<K>) {\n  const $keyed = ActualMessage(_keyed);\n  return Message<R>(function () {\n    All($base, $keyed).pipe(\n      Tap(([base, keyed]) => {\n        const keys = keyed.split(\".\");\n        let value: unknown = base;\n        keys.forEach((key) => {\n          value = (value as Record<string, unknown>)[key];\n        });\n        if (value !== undefined && value !== base) {\n          this.use(value as R);\n        }\n      }),\n    );\n  });\n}\n","import { Message, MessageType, Tap } from \"silentium\";\n\n/**\n * Active polling of $base message\n * synchronized with $trigger message\n */\nexport function Polling<T>($base: MessageType<T>, $trigger: MessageType<T>) {\n  return Message<T>(function () {\n    $trigger.pipe(\n      Tap(() => {\n        $base.pipe(this);\n      }),\n    );\n  });\n}\n","import { isFilled, Message, MessageType, Primitive, Tap } from \"silentium\";\n\n/**\n * Helps to represent only last fresh value Of some source, refreshing controls by shotSrc\n * https://silentium-lab.github.io/silentium-components/#/behaviors/shot\n */\nexport function Shot<T>($target: MessageType<T>, $trigger: MessageType) {\n  return Message<T>(function () {\n    const targetSync = Primitive($target);\n    targetSync.primitive();\n    $trigger.pipe(\n      Tap(() => {\n        const value = targetSync.primitive();\n        if (isFilled(value)) {\n          this.use(value);\n        }\n      }),\n    );\n  });\n}\n","import { ExecutorApplied, Message, MessageType } from \"silentium\";\n\n/**\n * Defer a message to the event loop\n * so that it executes once within\n * a certain timer firing interval\n */\nexport function Task<T>(baseSrc: MessageType<T>, delay: number = 0) {\n  return Message<T>(function () {\n    let prevTimer: unknown | null = null;\n    ExecutorApplied(baseSrc, (fn) => {\n      return (v) => {\n        if (prevTimer) {\n          clearTimeout(prevTimer as number);\n        }\n        prevTimer = setTimeout(() => {\n          fn(v);\n        }, delay);\n      };\n    }).pipe(this);\n  });\n}\n","import { Message, MessageType, Tap } from \"silentium\";\n\n/**\n * Accumulates the last value Of the source and returns one result once per tick\n * https://silentium-lab.github.io/silentium-components/#/behaviors/tick\n */\nexport function Tick<T>($base: MessageType<T>) {\n  return Message(function () {\n    let microtaskScheduled = false;\n    let lastValue: T | null = null;\n\n    const scheduleMicrotask = () => {\n      microtaskScheduled = true;\n      queueMicrotask(() => {\n        microtaskScheduled = false;\n        if (lastValue !== null) {\n          this.use(lastValue);\n          lastValue = null;\n        }\n      });\n    };\n\n    $base.pipe(\n      Tap((v) => {\n        lastValue = v;\n        if (!microtaskScheduled) {\n          scheduleMicrotask();\n        }\n      }),\n    );\n  });\n}\n","import {\n  ConstructorType,\n  DestroyableType,\n  LateShared,\n  Message,\n  MessageType,\n  Of,\n  Tap,\n} from \"silentium\";\nimport { Detached } from \"../behaviors/Detached\";\n\n/**\n * Do something on message value.\n * Each message value will create new builder instance\n */\nexport function Transaction<T, R = unknown>(\n  $base: MessageType<T>,\n  builder: ConstructorType<\n    [MessageType<T>, ...MessageType<any>[]],\n    MessageType<R>\n  >,\n  ...args: MessageType[]\n) {\n  return Message<R>(function () {\n    const $res = LateShared<R>();\n    const destructors: DestroyableType[] = [];\n\n    $base.pipe(\n      Tap((v) => {\n        const $msg = builder(Of(v), ...args.map((a) => Detached(a)));\n        destructors.push($msg as unknown as DestroyableType);\n        $msg.pipe($res);\n      }),\n    );\n    $res.pipe(this);\n\n    return () => {\n      destructors.forEach((d) => d?.destroy());\n      destructors.length = 0;\n    };\n  });\n}\n","import { Message, MessageType, Tap } from \"silentium\";\n\n/**\n * By receiving a message with a key and value, collects a table\n * of all previously received messages in the form of a structure\n * https://silentium-lab.github.io/silentium-components/#/structures/hash-table\n */\nexport function HashTable<T>($base: MessageType<[string, unknown]>) {\n  return Message<T>(function () {\n    const record: Record<string, unknown> = {};\n\n    $base.pipe(\n      Tap(([key, value]) => {\n        record[key] = value;\n        this.use(record as T);\n      }),\n    );\n  });\n}\n","import { All, isMessage, Message, MessageType, Of, Tap } from \"silentium\";\n\ntype UnWrap<T> = T extends MessageType<infer U> ? U : T;\n\n/**\n * Returns record Of data from record Of sources\n * https://silentium-lab.github.io/silentium-components/#/structures/record\n */\nexport function Record<T>(record: Record<string, T>) {\n  return Message<Record<string, UnWrap<T>>>(function () {\n    const keys = Object.keys(record);\n    keys.forEach((key) => {\n      if (!isMessage(record[key])) {\n        record[key] = Of(record[key]) as any;\n      }\n    });\n    All(...(Object.values(record) as any)).pipe(\n      Tap((entries) => {\n        const record: Record<string, any> = {};\n        entries.forEach((entry, index) => {\n          record[keys[index]] = entry;\n        });\n        this.use(record);\n      }),\n    );\n  });\n}\n","import { All, Message, MessageType, Of, Tap } from \"silentium\";\n\n/**\n * Join sources Of strings to one source\n * https://silentium-lab.github.io/silentium-components/#/string/concatenated\n */\nexport function Concatenated(\n  sources: MessageType<string>[],\n  joinPartSrc: MessageType<string> = Of(\"\"),\n) {\n  return Message<string>(function () {\n    All(joinPartSrc, ...sources).pipe(\n      Tap(([joinPart, ...strings]) => {\n        this.use(strings.join(joinPart));\n      }),\n    );\n  });\n}\n","import {\n  All,\n  Applied,\n  DestroyableType,\n  DestroyContainer,\n  isDestroyable,\n  MessageType,\n  Of,\n  TapType,\n} from \"silentium\";\nimport { Record } from \"../structures\";\n\n/**\n * Allows creating a string template with\n * variables inserted into it; when variables change,\n * the template value will change\n */\nexport function Template(\n  $src: MessageType<string> = Of(\"\"),\n  $places: MessageType<Record<string, unknown>> = Of({}),\n) {\n  return new TemplateImpl($src, $places);\n}\n\nclass TemplateImpl implements MessageType<string>, DestroyableType {\n  private dc = DestroyContainer();\n  private vars: Record<string, MessageType> = {\n    $TPL: Of(\"$TPL\"),\n  };\n\n  public constructor(\n    private $src: MessageType<string> = Of(\"\"),\n    private $places: MessageType<Record<string, unknown>> = Of({}),\n  ) {}\n\n  public pipe(transport: TapType<string>): this {\n    const $vars = Record(this.vars);\n    Applied(All(this.$src, this.$places, $vars), ([base, rules, vars]) => {\n      Object.entries(rules).forEach(([ph, val]) => {\n        base = base.replaceAll(ph, String(val));\n      });\n      Object.entries(vars).forEach(([ph, val]) => {\n        base = base.replaceAll(ph, String(val));\n      });\n\n      return base;\n    }).pipe(transport);\n    return this;\n  }\n\n  public template(value: string) {\n    this.$src = Of(value);\n  }\n\n  /**\n   * Ability to register variable\n   * in concrete place Of template\n   */\n  public var(src: MessageType<string>) {\n    const places = Object.keys(this.vars).length;\n    const varName = `$var${places}`;\n    if (isDestroyable(src)) {\n      this.dc.add(src);\n    }\n    this.vars[varName] = src;\n    return varName;\n  }\n\n  public destroy(): this {\n    this.dc.destroy();\n    return this;\n  }\n}\n","import { All, Message, MessageType, Of, Tap } from \"silentium\";\n\n/**\n * Boolean source what checks what string matches pattern\n * https://silentium-lab.github.io/silentium-components/#/system/regexp-matched\n */\nexport function RegexpMatched(\n  patternSrc: MessageType<string>,\n  valueSrc: MessageType<string>,\n  flagsSrc: MessageType<string> = Of(\"\"),\n) {\n  return Message<boolean>(function () {\n    All(patternSrc, valueSrc, flagsSrc).pipe(\n      Tap(([pattern, value, flags]) => {\n        this.use(new RegExp(pattern, flags).test(value));\n      }),\n    );\n  });\n}\n","import { All, Message, MessageType, Of, Tap } from \"silentium\";\n\n/**\n * Returns string replaced by regular expression pattern\n * https://silentium-lab.github.io/silentium-components/#/system/regexp-replaced\n */\nexport function RegexpReplaced(\n  valueSrc: MessageType<string>,\n  patternSrc: MessageType<string>,\n  replaceValueSrc: MessageType<string>,\n  flagsSrc: MessageType<string> = Of(\"\"),\n) {\n  return Message<string>(function () {\n    All(patternSrc, valueSrc, replaceValueSrc, flagsSrc).pipe(\n      Tap(([pattern, value, replaceValue, flags]) => {\n        this.use(\n          String(value).replace(new RegExp(pattern, flags), replaceValue),\n        );\n      }),\n    );\n  });\n}\n","import { All, Message, MessageType, Of, Tap } from \"silentium\";\n\n/**\n * First match Of regexp\n * https://silentium-lab.github.io/silentium-components/#/system/regexp-matched\n */\nexport function RegexpMatch(\n  patternSrc: MessageType<string>,\n  valueSrc: MessageType<string>,\n  flagsSrc: MessageType<string> = Of(\"\"),\n) {\n  return Message<string[]>(function () {\n    All(patternSrc, valueSrc, flagsSrc).pipe(\n      Tap(([pattern, value, flags]) => {\n        const result = new RegExp(pattern, flags).exec(value);\n        this.use(result ?? []);\n      }),\n    );\n  });\n}\n","import { All, Message, MessageType, Tap } from \"silentium\";\n\n/**\n * Ability to mutate some object, helpful when integrate to procedure systems\n * https://silentium-lab.github.io/silentium-components/#/system/set\n */\nexport function Set<T extends Record<string, unknown>>(\n  baseSrc: MessageType<T>,\n  keySrc: MessageType<string>,\n  valueSrc: MessageType<unknown>,\n) {\n  return Message<T>(function () {\n    All(baseSrc, keySrc, valueSrc).pipe(\n      Tap(([base, key, value]) => {\n        (base as Record<string, unknown>)[key] = value;\n        this.use(base);\n      }),\n    );\n  });\n}\n","import {\n  All,\n  DestroyableType,\n  DestroyContainer,\n  Message,\n  MessageType,\n  Of,\n  Tap,\n  TapType,\n} from \"silentium\";\nimport { RegexpMatched } from \"../system\";\n\nexport interface Route<T> {\n  pattern: string;\n  patternFlags?: string;\n  message: TapType<void, MessageType<T>>;\n}\n\n/**\n * Router component what will return template if url matches pattern\n * https://silentium-lab.github.io/silentium-components/#/navigation/router\n */\nexport function Router<T = \"string\">(\n  $url: MessageType<string>,\n  $routes: MessageType<Route<T>[]>,\n  $default: TapType<void, MessageType<T>>,\n): MessageType<T> & DestroyableType {\n  return Message<T>(function () {\n    const dc = DestroyContainer();\n    const destructor = () => {\n      dc.destroy();\n    };\n    All($routes, $url).pipe(\n      Tap(([routes, url]) => {\n        destructor();\n        const $matches = All(\n          ...routes.map((r) =>\n            RegexpMatched(\n              Of(r.pattern),\n              Of(url),\n              r.patternFlags ? Of(r.patternFlags) : undefined,\n            ),\n          ),\n        );\n        $matches.pipe(\n          Tap((matches) => {\n            const index = matches.findIndex((v) => v === true);\n\n            if (index === -1) {\n              const instance = $default.use();\n              dc.add(instance);\n              instance.pipe(this);\n            }\n\n            if (index > -1) {\n              const instance = routes[index].message.use();\n              dc.add(instance);\n              instance.pipe(this);\n            }\n          }),\n        );\n      }),\n    );\n\n    return destructor;\n  });\n}\n","import { All, Message, MessageType, Tap } from \"silentium\";\n\n/**\n * Logical AND over two messages\n * https://silentium-lab.github.io/silentium-components/#/boolean/and\n */\nexport function And($one: MessageType<boolean>, $two: MessageType<boolean>) {\n  return Message<boolean>(function () {\n    All($one, $two).pipe(\n      Tap(([one, two]) => {\n        this.use(!!(one && two));\n      }),\n    );\n  });\n}\n","import { All, Message, MessageType, Tap } from \"silentium\";\n\n/**\n * Logical OR over two messages\n * https://silentium-lab.github.io/silentium-components/#/boolean/or\n */\nexport function Or($one: MessageType<boolean>, $two: MessageType<boolean>) {\n  return Message<boolean>(function () {\n    All($one, $two).pipe(\n      Tap(([one, two]) => {\n        this.use(!!(one || two));\n      }),\n    );\n  });\n}\n","import { Message, MessageType, Tap } from \"silentium\";\n\n/**\n * Logical negation of message\n * https://silentium-lab.github.io/silentium-components/#/boolean/not\n */\nexport function Not($base: MessageType<boolean>) {\n  return Message<boolean>(function () {\n    $base.pipe(\n      Tap((v) => {\n        this.use(!v);\n      }),\n    );\n  });\n}\n","import { Applied, Message, MessageType } from \"silentium\";\n\n/**\n * Convert Any source to boolean source\n * https://silentium-lab.github.io/silentium-components/#/boolean/bool\n */\nexport function Bool($base: MessageType) {\n  return Message<boolean>(function () {\n    Applied($base, Boolean).pipe(this);\n  });\n}\n","import { Message, MessageType, Tap, TapType } from \"silentium\";\n\n/**\n * Represents object from json\n */\nexport function FromJson<T = Record<string, unknown>>(\n  $json: MessageType<string>,\n  error?: TapType,\n) {\n  return Message<T>(function () {\n    $json.pipe(\n      Tap((json) => {\n        try {\n          this.use(JSON.parse(json));\n        } catch (e) {\n          error?.use(new Error(`Failed to parse JSON: ${e}`));\n        }\n      }),\n    );\n  });\n}\n","import { Message, MessageType, Tap, TapType } from \"silentium\";\n\n/**\n * Represents json from object\n */\nexport function ToJson($data: MessageType, error?: TapType) {\n  return Message<string>(function () {\n    $data.pipe(\n      Tap((data: unknown) => {\n        try {\n          this.use(JSON.stringify(data));\n        } catch {\n          error?.use(new Error(\"Failed to convert to JSON\"));\n        }\n      }),\n    );\n  });\n}\n","import { Applied, Message, MessageType } from \"silentium\";\n\n/**\n * Represents the first element Of an array.\n */\nexport function First<T extends Array<unknown>>($base: MessageType<T>) {\n  return Message<T[0]>(function () {\n    Applied($base, (a) => a[0]).pipe(this);\n  });\n}\n"],"names":["Branch","_condition","_left","_right","$condition","ActualMessage","$left","$right","Message","left","Primitive","right","pipe","Tap","v","result","primitive","this","use","BranchLazy","dc","DestroyContainer","destructor","destroy","instance","add","Constant","permanent","$trigger","Deadline","error","$base","_timeout","$timeout","timer","base","Shared","timeout","clearTimeout","timeoutReached","setTimeout","Error","Filtered","Deferred","value","isFilled","Detached","Dirty","keep","exclude","cloner","DirtySource","constructor","__publicField","Late","JSON","parse","stringify","transport","$comparing","Applied","All","comparing","Object","fromEntries","entries","filter","key","includes","Loading","$start","$finish","Lock","$lock","locked","newLock","Memo","last","OnlyChanged","first","Part","$key","PartImpl","SharedSource","$keyed","keyed","keys","split","forEach","primitiveWithException","Path","_keyed","Polling","Shot","$target","targetSync","Task","baseSrc","delay","prevTimer","ExecutorApplied","fn","Tick","microtaskScheduled","lastValue","scheduleMicrotask","queueMicrotask","Transaction","builder","args","$res","LateShared","destructors","$msg","Of","map","a","push","d","length","HashTable","record","Record","isMessage","values","entry","index","Concatenated","sources","joinPartSrc","joinPart","strings","join","Template","$src","$places","TemplateImpl","$TPL","$vars","vars","rules","ph","val","replaceAll","String","template","src","varName","isDestroyable","RegexpMatched","patternSrc","valueSrc","flagsSrc","pattern","flags","RegExp","test","RegexpReplaced","replaceValueSrc","replaceValue","replace","RegexpMatch","exec","Set","keySrc","Router","$url","$routes","$default","routes","url","r","patternFlags","matches","findIndex","message","And","$one","$two","one","two","Or","Not","Bool","Boolean","FromJson","$json","json","e","ToJson","$data","data","First"],"mappings":"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"}