!function(e,r){"use strict";const u=(e,u,o="")=>r.sourceCombined(e,u,o)(((e,u,o,t)=>{r.give(new RegExp(u,t).test(o),e)}));e.and=(e,u)=>r.sourceCombined(e,u)(((e,u,o)=>{r.give(u&&o,e)})),e.branch=(e,u,o)=>{const t=r.sourceOf();return r.value(e,r.patron((e=>{!0===e?r.value(u,r.patronOnce((e=>{t.give(e)}))):void 0!==o&&r.value(o,r.patronOnce((e=>{t.give(e)})))}))),t.value},e.concatenated=(e,u="")=>r.sourceCombined(u,...e)(((e,u,...o)=>{r.give(o.join(u),e)})),e.deadline=(e,u,o)=>{let t=null;return n=>{r.value(o,r.guestCast(n,(o=>{t&&clearTimeout(t);let a=!1;t=setTimeout((()=>{a||(a=!0,r.give(new Error("Timeout reached in Deadline class"),e))}),o),r.value(r.sourceFiltered(u,(()=>!a)),n),r.value(u,r.patronOnce((()=>{a=!0})))})))}},e.deferred=(e,u)=>{const o=r.sourceResettable(r.sourceOf(),e);return r.value(u,r.patron((()=>{r.value(e,o)}))),o.value},e.dirty=(e,u=!1,o=[],t=[])=>{const n=r.sourceOf(),a=r.sourceAll([n,e]),s={give:e=>(r.give(JSON.parse(JSON.stringify(e)),n),s),value:e=>(r.value(a,r.guestCast(e,(([u,n])=>{u&&r.give(Object.fromEntries(Object.entries(u).filter((([e,r])=>!!o.includes(e)||!t.includes(e)&&r!==n[e]))),e)}))),s)};return u&&r.value(e,r.patronOnce(s)),s},e.fork=(e,u,o,t)=>{const n=r.sourceOf(),a=r.sourceOf(),s=r.sourceResettable(n,a);let l,c;return r.value(e,r.patron((e=>{a.give(1),l&&r.removePatronFromPools(l),c&&r.removePatronFromPools(c),u(e)?(l=r.patronOnce(n),r.value(o,l)):t&&(c=r.patronOnce(n),r.value(t,c))}))),s},e.groupActiveClass=(e,u,o)=>(r.value(r.sourceAll([e,u,o]),r.patron((([e,r,u])=>{u.forEach((r=>{r.classList&&r.classList.remove(e)})),r.classList.add(e)}))),o),e.hashTable=e=>{const u=r.sourceOf({});return r.subSource(u,e),r.value(e,r.patron((([e,r])=>{u.value((u=>{u[e]=r}))}))),u.value},e.loading=(e,u)=>{const o=r.sourceOf();return r.subSourceMany(o,[e,u]),r.value(e,r.patron((()=>{o.give(!0)}))),r.value(u,r.patron((()=>{o.give(!1)}))),o.value},e.lock=(e,u)=>{const o=r.sourceOf(),t=r.sourceResettable(o,u);let n=!1;return r.subSource(o,e),r.value(e,r.patron(r.guestDisposable(o.give,(()=>n)))),r.value(u,r.patronOnce((()=>{n=!0,r.destroy([o])}))),t.value},e.memo=e=>{const u=r.sourceOf();let o=null;return r.value(e,r.patron((e=>{e!==o&&(u.give(e),o=e)}))),u.value},e.moment=(e,u)=>{const o=r.guestSync(u);return r.value(e,o),e=>{r.give(o.value(),e)}},e.not=e=>u=>{r.value(e,r.guestCast(u,(e=>{r.give(!e,u)})))},e.onlyChanged=e=>{let u=r.sourceSync(e,null).syncValue();return r.source((o=>{r.value(e,r.guestCast(o,(e=>{null===u?u=e:u!==e&&r.give(e,o)})))}))},e.or=(e,u)=>r.sourceCombined(e,u)(((e,u,o)=>{r.give(u||o,e)})),e.path=(e,u)=>{const o=r.sourceOf();return r.subSourceMany(o,[e,u]),r.value(r.sourceAll([e,u]),r.patron((([e,u])=>{const t=u.split(".");let n=e;t.forEach((e=>{n=n[e]})),void 0!==n&&n!==e&&r.give(n,o)}))),o.value},e.record=e=>{const u=Object.keys(e);return r.sourceCombined(...Object.values(e))(((e,...o)=>{const t={};o.forEach(((e,r)=>{t[u[r]]=e})),r.give(t,e)}))},e.regexpMatch=(e,u,o="")=>r.sourceCombined(e,u,o)(((e,u,o,t)=>{const n=new RegExp(u,t).exec(o);r.give(n??[],e)})),e.regexpMatched=u,e.regexpReplaced=(e,u,o,t="")=>r.sourceCombined(u,e,o,t)(((e,u,o,t,n)=>{r.give(String(o).replace(new RegExp(u,n),t),e)})),e.router=(e,o,t)=>{const n=r.sourceOf();return r.value(o,r.patron((o=>{r.value(r.sourceAny([r.sourceChain(e,t),...o.map((o=>r.sourceChain(r.sourceFiltered(u(o.pattern,e,o.patternFlags),Boolean),o.template)))]),r.patron(n))}))),n.value},e.set=(e,u,o)=>(r.value(r.sourceAll([e,u,o]),r.patron((([e,r,u])=>{e[r]=u}))),e),e.shot=(e,u)=>{const o=r.sourceOf(),t=r.sourceOf(),n=r.sourceSync(e,null);return r.value(u,r.patron((()=>{null!==n.syncValue()&&(t.give(n.syncValue()),o.give(1))}))),r.sourceResettable(t,o)},e.tick=e=>{const u=r.sourceOf();r.subSource(u,e);let o=!1,t=null;return r.value(e,r.patron((e=>{t=e,o||(o=!0,queueMicrotask((()=>{o=!1,null!==t&&(r.give(t,u),t=null)})))}))),u}}({},silentium);
