!function(e,t){"use strict";const s=(e,s,r)=>{const u=t.sourceOf(),o=t.sourceOf(),a=t.sourceResettable(o,u),n=t.firstVisit((()=>{t.value(e,t.systemPatron((e=>{u.give(1),!0===e?t.value(s,t.patronOnce(o.give)):void 0!==r&&t.value(r,t.patronOnce(o.give))})))}));return e=>{n(),a.value(e)}},r=(e,s,r="")=>t.sourceCombined(e,s,r)(((e,s,r,u)=>{t.give(new RegExp(s,u).test(r),e)}));e.and=(e,s)=>t.sourceCombined(e,s)(((e,s,r)=>{t.give(s&&r,e)})),e.branch=s,e.concatenated=(e,s="")=>t.sourceCombined(s,...e)(((e,s,...r)=>{t.give(r.join(s),e)})),e.deadline=(e,s,r)=>{let u=null;return o=>{t.value(r,t.guestCast(o,(r=>{u&&clearTimeout(u);let a=!1;u=setTimeout((()=>{a||(a=!0,t.give(new Error("Timeout reached in Deadline class"),e))}),r),t.value(t.sourceFiltered(s,(()=>!a)),o),t.value(s,t.patronOnce((()=>{a=!0})))})))}},e.deferred=(e,s)=>{const r=t.sourceResettable(t.sourceOf(),e),u=t.firstVisit((()=>{t.value(s,t.systemPatron((()=>{t.value(e,r)})))}));return e=>{u(),t.value(r,e)}},e.dirty=(e,s=!1,r=[],u=[])=>{const o=t.sourceOf(),a=t.sourceAll([o,e]),n={give:e=>(t.give(JSON.parse(JSON.stringify(e)),o),n),value:e=>(t.value(a,t.guestCast(e,(([s,o])=>{s&&t.give(Object.fromEntries(Object.entries(s).filter((([e,t])=>!!r.includes(e)||!u.includes(e)&&t!==o[e]))),e)}))),n)};return s&&t.value(e,t.patronOnce(n)),n},e.fork=(e,s,r,u)=>{const o=t.sourceOf(),a=t.sourceOf(),n=t.sourceResettable(o,a);let l,c;return t.value(e,t.systemPatron((e=>{a.give(1),l&&t.removePatronFromPools(l),c&&t.removePatronFromPools(c),s(e)?(l=t.patronOnce(o),t.value(r,l)):u&&(c=t.patronOnce(o),t.value(u,c))}))),n},e.groupActiveClass=(e,s,r)=>(t.value(t.sourceAll([e,s,r]),t.systemPatron((([e,t,s])=>{s.forEach((t=>{t.classList&&t.classList.remove(e)})),t.classList.add(e)}))),r),e.hashTable=e=>{const s=t.sourceOf({});return t.subSource(s,e),t.value(e,t.systemPatron((([e,t])=>{s.value((s=>{s[e]=t}))}))),s.value},e.loading=(e,s)=>{const r=t.sourceOf();return t.subSourceMany(r,[e,s]),t.value(e,t.systemPatron((()=>{r.give(!0)}))),t.value(s,t.systemPatron((()=>{r.give(!1)}))),r.value},e.lock=(e,s)=>{const r=t.sourceOf(),u=t.sourceResettable(r,s);let o=!1;return t.subSource(r,e),t.value(e,t.systemPatron(t.guestDisposable(r.give,(()=>o)))),t.value(s,t.patronOnce((()=>{o=!0,t.destroy([r])}))),u},e.memo=e=>{const s=t.sourceOf();let r=null;return t.value(e,t.systemPatron((e=>{e!==r&&(s.give(e),r=e)}))),s.value},e.moment=(e,s)=>{const r=t.guestSync(s);return t.value(e,r),e=>{t.give(r.value(),e)}},e.not=e=>s=>{t.value(e,t.guestCast(s,(e=>{t.give(!e,s)})))},e.onlyChanged=e=>{let s=!1;return t.source((r=>{t.value(e,t.guestCast(r,(e=>{!1===s?s=!0:t.give(e,r)})))}))},e.or=(e,s)=>t.sourceCombined(e,s)(((e,s,r)=>{t.give(s||r,e)})),e.path=(e,s)=>{const r=t.sourceOf();return t.subSourceMany(r,[e,s]),t.value(t.sourceAll([e,s]),t.systemPatron((([e,s])=>{const u=s.split(".");let o=e;u.forEach((e=>{o=o[e]})),void 0!==o&&o!==e&&t.give(o,r)}))),r.value},e.record=e=>{const s=Object.keys(e);return t.sourceCombined(...Object.values(e))(((e,...r)=>{const u={};r.forEach(((e,t)=>{u[s[t]]=e})),t.give(u,e)}))},e.regexpMatch=(e,s,r="")=>t.sourceCombined(e,s,r)(((e,s,r,u)=>{const o=new RegExp(s,u).exec(r);t.give(o??[],e)})),e.regexpMatched=r,e.regexpReplaced=(e,s,r,u="")=>t.sourceCombined(s,e,r,u)(((e,s,r,u,o)=>{t.give(String(r).replace(new RegExp(s,o),u),e)})),e.router=(e,u,o)=>{const a=t.sourceOf(),n=t.firstVisit((()=>{t.value(u,t.patronOnce((u=>{var n;const l=((e,s)=>{const r=t.sourceOf(),u=t.firstVisit((()=>{t.value(s,t.systemPatron((()=>{t.value(e,r)})))}));return e=>{u(),r.value(e)}})((n=[o,...u.map((u=>t.value(s(r(u.pattern,e,u.patternFlags),u.template),t.systemPatron((e=>e)))))],e=>{let s,r=0;n.forEach(((e,u)=>{t.value(e,(e=>{r<=u&&(r=u,s=e)}))})),void 0!==s&&t.give(s,e)}),e);t.value(l,t.systemPatron(a))})))}));return e=>{n(),a.value(e)}},e.set=(e,s,r)=>(t.value(t.sourceAll([e,s,r]),t.systemPatron((([e,t,s])=>{e[t]=s}))),e),e.shot=(e,s)=>{const r=t.sourceOf(),u=t.sourceOf(),o=t.sourceSync(e,null);return t.value(s,t.systemPatron((()=>{null!==o.syncValue()&&(u.give(o.syncValue()),r.give(1))}))),t.sourceResettable(u,r)},e.tick=e=>{const s=t.sourceOf();t.subSource(s,e);let r=!1,u=null;return t.value(e,t.systemPatron((e=>{u=e,r||(r=!0,queueMicrotask((()=>{r=!1,null!==u&&(t.give(u,s),u=null)})))}))),s}}({},silentium);
