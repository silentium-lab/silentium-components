!function(e,t){"use strict";var r=Object.defineProperty,s=(e,t,s)=>((e,t,s)=>t in e?r(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s)(e,"symbol"!=typeof t?t+"":t,s);class n extends t.TheInformation{constructor(e){super(e),this.baseSrc=e,s(this,"theValue"),s(this,"isInit",!1)}value(e){return this.baseSrc.value(e),this}valueExisted(){return this.initOwner(),t.isFilled(this.theValue)}valueSync(){if(this.initOwner(),!t.isFilled(this.theValue))throw new Error("no value in sync");return this.theValue}initOwner(){return this.isInit||(this.isInit=!0,this.value(new t.From((e=>{this.theValue=e})))),this}}class i extends t.TheInformation{constructor(e,t,r){super([e,t,r]),this.conditionSrc=e,this.leftSrc=t,this.rightSrc=r}value(e){const r=new n(this.leftSrc).initOwner();let s;return void 0!==this.rightSrc&&(s=new n(this.rightSrc).initOwner()),this.conditionSrc.value(new t.From((t=>{t?e.give(r.valueSync()):s&&e.give(s.valueSync())}))),this}}class a extends t.TheInformation{constructor(e,t,r){super([e,t,r]),this.error=e,this.baseSrc=t,this.timeoutSrc=r}value(e){let r=null;const s=new t.Shared(this.baseSrc,!0);return this.addDep(s),this.timeoutSrc.value(new t.From((n=>{r&&clearTimeout(r);let i=!1;r=setTimeout((()=>{i||(i=!0,this.error.give(new Error("Timeout reached in Deadline class")))}),n);const a=new t.Filtered(s,(()=>!i));this.addDep(a),a.value(e),s.value(new t.From((()=>{i=!0})))}))),this}}class c extends t.TheInformation{constructor(e,t){super(),this.baseSrc=e,this.triggerSrc=t}value(e){const r=new n(this.baseSrc).initOwner();return this.triggerSrc.value(new t.From((()=>{t.isFilled(r.valueSync())&&e.give(r.valueSync())}))),this}}var o=Object.defineProperty,l=(e,t,r)=>((e,t,r)=>t in e?o(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,t+"",r);class u extends t.TheInformation{constructor(e,r=[],s=[]){super([e]),this.baseEntitySource=e,this.alwaysKeep=r,this.excludeKeys=s,l(this,"comparingSrc",new t.Late)}value(e){const r=new t.Applied(this.comparingSrc,(e=>JSON.parse(JSON.stringify(e)))),s=new t.All(r,this.baseEntitySource).value(new t.From((([t,r])=>{t&&e.give(Object.fromEntries(Object.entries(t).filter((([e,t])=>!!this.alwaysKeep.includes(e)||!this.excludeKeys.includes(e)&&t!==r[e]))))})));return this.addDep(s),this}owner(){return this.comparingSrc.owner()}}class h extends t.TheInformation{constructor(e,t){super(t,e),this.loadingStartSrc=e,this.loadingFinishSrc=t}value(e){return this.loadingStartSrc.value(new t.From((()=>{e.give(!0)}))),this.loadingFinishSrc.value(new t.From((()=>{e.give(!1)}))),this}}class S extends t.TheInformation{constructor(e,t){super(e,t),this.baseSrc=e,this.lockSrc=t}value(e){let r=!1;this.lockSrc.value(new t.From((e=>{r=e})));const s=new t.Filtered(this.baseSrc,(()=>!r));return this.addDep(s),s.value(e),this}}class v extends t.TheInformation{constructor(e){super(e),this.baseSrc=e}value(e){let r=null;return this.baseSrc.value(new t.From((t=>{t!==r&&(e.give(t),r=t)}))),this}}class w extends t.TheInformation{constructor(e){super(e),this.baseSrc=e}value(e){let r=!1;return this.baseSrc.value(new t.From((t=>{!1===r?r=!0:e.give(t)}))),this}}class d extends t.TheInformation{constructor(e,t){super(e,t),this.baseSrc=e,this.keySrc=t}value(e){const r=new t.All(this.baseSrc,this.keySrc).value(new t.From((([t,r])=>{const s=r.split(".");let n=t;s.forEach((e=>{n=n[e]})),void 0!==n&&n!==t&&e.give(n)})));return this.addDep(r),this}}class p extends t.TheInformation{constructor(e,t){super(e,t),this.targetSrc=e,this.triggerSrc=t}value(e){const r=new n(this.targetSrc);return r.initOwner(),this.triggerSrc.value(new t.From((()=>{r.valueExisted()&&e.give(r.valueSync())}))),this}}class m extends t.TheInformation{constructor(e){super(e),this.baseSrc=e}value(e){let r=!1,s=null;return this.baseSrc.value(new t.From((t=>{s=t,r||(r=!0,queueMicrotask((()=>{r=!1,null!==s&&(e.give(s),s=null)})))}))),this}}class g extends t.TheInformation{constructor(e){super(e),this.baseSrc=e}value(e){const r={};return this.baseSrc.value(new t.From((([t,s])=>{r[t]=s,e.give(r)}))),this}}class f extends t.TheInformation{constructor(e){super(...Object.values(e)),this.recordSrc=e}value(e){const r=Object.keys(this.recordSrc);return new t.All(...Object.values(this.recordSrc)).value(new t.From((t=>{const s={};t.forEach(((e,t)=>{s[r[t]]=e})),e.give(s)}))),this}}class b extends t.TheInformation{constructor(e,r=new t.Of("")){super(...e,r),this.sources=e,this.joinPartSrc=r}value(e){return new t.All(this.joinPartSrc,...this.sources).value(new t.From((([t,...r])=>{e.give(r.join(t))}))),this}}var F=Object.defineProperty,x=(e,t,r)=>((e,t,r)=>t in e?F(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,t+"",r);class O extends t.TheInformation{constructor(e,r){const s="string"==typeof e?new t.Of(e):e;super(s,r),this.rules=r,x(this,"source"),this.source=s}value(e){return new t.Applied(new t.All(this.source,this.rules),(([e,t])=>(Object.entries(t).forEach((([t,r])=>{e=e.replaceAll(t,String(r))})),e))).value(e),this}}class T extends t.TheInformation{constructor(e,r,s=new t.Of("")){super(e,r,s),this.patternSrc=e,this.valueSrc=r,this.flagsSrc=s}value(e){return new t.All(this.patternSrc,this.valueSrc,this.flagsSrc).value(new t.From((([t,r,s])=>{e.give(new RegExp(t,s).test(r))}))),this}}class y extends t.TheInformation{constructor(e,r,s,n=new t.Of("")){super(e,r,s,n),this.valueSrc=e,this.patternSrc=r,this.replaceValueSrc=s,this.flagsSrc=n}value(e){return new t.All(this.patternSrc,this.valueSrc,this.replaceValueSrc,this.flagsSrc).value(new t.From((([t,r,s,n])=>{e.give(String(r).replace(new RegExp(t,n),s))}))),this}}class I extends t.TheInformation{constructor(e,r,s=new t.Of("")){super(e,r,s),this.patternSrc=e,this.valueSrc=r,this.flagsSrc=s}value(e){return new t.All(this.patternSrc,this.valueSrc,this.flagsSrc).value(new t.From((([t,r,s])=>{const n=new RegExp(t,s).exec(r);e.give(n??[])}))),this}}class A extends t.TheInformation{constructor(e,t,r){super(e,t,r),this.baseSrc=e,this.keySrc=t,this.valueSrc=r}value(e){return new t.All(this.baseSrc,this.keySrc,this.valueSrc).value(new t.From((([t,r,s])=>{t[r]=s,e.give(t)}))),this}}class E extends t.TheInformation{constructor(e,t,r){super(e,t,r),this.urlSrc=e,this.routesSrc=t,this.defaultSrc=r}value(e){return this.routesSrc.value(new t.From((r=>{new t.Any(new t.Chain(this.urlSrc,this.defaultSrc),...r.map((e=>new i(new T(new t.Of(e.pattern),this.urlSrc,e.patternFlags?new t.Of(e.patternFlags):void 0),"value"in e.template?e.template:new t.Of(e.template))))).value(e)}))),this}}class j extends t.TheInformation{constructor(e,t){super(e,t),this.oneSrc=e,this.twoSrc=t}value(e){return new t.All(this.oneSrc,this.twoSrc).value(new t.From((([t,r])=>{e.give(t&&r)}))),this}}class k extends t.TheInformation{constructor(e,t){super(e,t),this.oneSrc=e,this.twoSrc=t}value(e){return new t.All(this.oneSrc,this.twoSrc).value(new t.From((([t,r])=>{e.give(t||r)}))),this}}class D extends t.TheInformation{constructor(e){super(e),this.baseSrc=e}value(e){return this.baseSrc.value(new t.From((t=>{e.give(!t)}))),this}}class R extends t.TheInformation{constructor(e){super(e),this.baseSrc=e}value(e){return new t.Applied(this.baseSrc,Boolean).value(e),this}}class J extends t.TheInformation{constructor(e,t){super(e),this.jsonSrc=e,this.errorOwner=t}value(e){return this.jsonSrc.value(new t.From((t=>{try{e.give(JSON.parse(t))}catch(e){this.errorOwner?.give(new Error(`Failed to parse JSON: ${e}`))}}))),this}}class N extends t.TheInformation{constructor(e,t){super(e),this.dataSrc=e,this.errorOwner=t}value(e){return this.dataSrc.value(new t.From((t=>{try{e.give(JSON.stringify(t))}catch{this.errorOwner?.give(new Error("Failed to convert to JSON"))}}))),this}}class V extends t.TheInformation{constructor(e){super(e),this.baseSrc=e}value(e){return new t.Applied(this.baseSrc,(e=>e[0])).value(e),this}}e.And=j,e.Bool=R,e.Branch=i,e.Concatenated=b,e.Deadline=a,e.Deferred=c,e.Dirty=u,e.First=V,e.FromJson=J,e.HashTable=g,e.Loading=h,e.Lock=S,e.Memo=v,e.Not=D,e.OnlyChanged=w,e.Or=k,e.Path=d,e.RecordOf=f,e.RegexpMatch=I,e.RegexpMatched=T,e.RegexpReplaced=y,e.Router=E,e.Set=A,e.Shot=p,e.Sync=n,e.Template=O,e.Tick=m,e.ToJson=N}({},silentium);
