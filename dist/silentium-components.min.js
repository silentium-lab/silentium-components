!function(e,r){"use strict";const u=(e,u,t="")=>r.sourceCombined(e,u,t)(((e,u,t,o)=>{r.give(new RegExp(u,o).test(t),e)}));e.and=(e,u)=>r.sourceCombined(e,u)(((e,u,t)=>{r.give(u&&t,e)})),e.branch=(e,u,t)=>{const o=r.sourceOf();return r.value(e,r.patron((e=>{!0===e?r.value(u,r.patronOnce((e=>{o.give(e)}))):void 0!==t&&r.value(t,r.patronOnce((e=>{o.give(e)})))}))),o.value},e.concatenated=(e,u="")=>r.sourceCombined(u,...e)(((e,u,...t)=>{r.give(t.join(u),e)})),e.deadline=(e,u,t)=>{let o=null;return n=>{r.value(t,r.guestCast(n,(t=>{o&&clearTimeout(o);let a=!1;o=setTimeout((()=>{a||(a=!0,r.give(new Error("Timeout reached in Deadline class"),e))}),t),r.value(r.sourceFiltered(u,(()=>!a)),n),r.value(u,r.patronOnce((()=>{a=!0})))})))}},e.deferred=(e,u)=>{const t=r.sourceResettable(r.sourceOf(),e);return r.value(u,r.patron((()=>{r.value(e,t)}))),t.value},e.dirty=(e,u=!1,t=[],o=[])=>{const n=r.sourceOf(),a=r.sourceAll([n,e]),s={give:e=>(r.give(JSON.parse(JSON.stringify(e)),n),s),value:e=>(r.value(a,r.guestCast(e,(([u,n])=>{u&&r.give(Object.fromEntries(Object.entries(u).filter((([e,r])=>!!t.includes(e)||!o.includes(e)&&r!==n[e]))),e)}))),s)};return u&&r.value(e,r.patronOnce(s)),s},e.fork=(e,u,t,o)=>{const n=r.sourceOf(),a=r.sourceOf(),s=r.sourceResettable(n,a);let l,c;return r.value(e,r.patron((e=>{a.give(1),l&&r.removePatronFromPools(l),c&&r.removePatronFromPools(c),u(e)?(l=r.patronOnce(n),r.value(t,l)):o&&(c=r.patronOnce(n),r.value(o,c))}))),s},e.groupActiveClass=(e,u,t)=>(r.value(r.sourceAll([e,u,t]),r.patron((([e,r,u])=>{u.forEach((r=>{r.classList&&r.classList.remove(e)})),r.classList.add(e)}))),t),e.hashTable=e=>{const u=r.sourceOf({});return r.subSource(u,e),r.value(e,r.patron((([e,r])=>{u.value((u=>{u[e]=r}))}))),u.value},e.loading=(e,u)=>{const t=r.sourceOf();return r.subSourceMany(t,[e,u]),r.value(e,r.patron((()=>{t.give(!0)}))),r.value(u,r.patron((()=>{t.give(!1)}))),t.value},e.lock=(e,u)=>{const t=r.sourceOf(),o=r.sourceResettable(t,u);let n=!1;return r.subSource(t,e),r.value(e,r.patron(r.guestDisposable(t.give,(()=>n)))),r.value(u,r.patronOnce((()=>{n=!0,r.destroy([t])}))),o.value},e.memo=e=>{const u=r.sourceOf();let t=null;return r.value(e,r.patron((e=>{e!==t&&(u.give(e),t=e)}))),u.value},e.moment=(e,u)=>{const t=r.guestSync(u);return r.value(e,t),e=>{r.give(t.value(),e)}},e.not=e=>u=>{r.value(e,r.guestCast(u,(e=>{r.give(!e,u)})))},e.onlyChanged=e=>{let u=!1;return r.source((t=>{r.value(e,r.guestCast(t,(e=>{!1===u?u=!0:r.give(e,t)})))}))},e.or=(e,u)=>r.sourceCombined(e,u)(((e,u,t)=>{r.give(u||t,e)})),e.path=(e,u)=>{const t=r.sourceOf();return r.subSourceMany(t,[e,u]),r.value(r.sourceAll([e,u]),r.patron((([e,u])=>{const o=u.split(".");let n=e;o.forEach((e=>{n=n[e]})),void 0!==n&&n!==e&&r.give(n,t)}))),t.value},e.record=e=>{const u=Object.keys(e);return r.sourceCombined(...Object.values(e))(((e,...t)=>{const o={};t.forEach(((e,r)=>{o[u[r]]=e})),r.give(o,e)}))},e.regexpMatch=(e,u,t="")=>r.sourceCombined(e,u,t)(((e,u,t,o)=>{const n=new RegExp(u,o).exec(t);r.give(n??[],e)})),e.regexpMatched=u,e.regexpReplaced=(e,u,t,o="")=>r.sourceCombined(u,e,t,o)(((e,u,t,o,n)=>{r.give(String(t).replace(new RegExp(u,n),o),e)})),e.router=(e,t,o)=>{const n=r.sourceOf();return r.value(t,r.patron((t=>{r.value(r.sourceAny([r.sourceChain(e,o),...t.map((t=>r.sourceChain(r.sourceFiltered(u(t.pattern,e,t.patternFlags),Boolean),t.template)))]),r.patron(n))}))),n.value},e.set=(e,u,t)=>(r.value(r.sourceAll([e,u,t]),r.patron((([e,r,u])=>{e[r]=u}))),e),e.shot=(e,u)=>{const t=r.sourceOf(),o=r.sourceOf(),n=r.sourceSync(e,null);return r.value(u,r.patron((()=>{null!==n.syncValue()&&(o.give(n.syncValue()),t.give(1))}))),r.sourceResettable(o,t).value},e.tick=e=>{const u=r.sourceOf();r.subSource(u,e);let t=!1,o=null;return r.value(e,r.patron((e=>{o=e,t||(t=!0,queueMicrotask((()=>{t=!1,null!==o&&(r.give(o,u),o=null)})))}))),u}}({},silentium);
