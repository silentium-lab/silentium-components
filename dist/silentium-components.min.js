!function(e,r){"use strict";const o=(e,o,t="")=>r.sourceCombined(e,o,t)(((e,o,t,u)=>{r.give(new RegExp(o,u).test(t),e)}));e.and=(e,o)=>r.sourceCombined(e,o)(((e,o,t)=>{r.give(o&&t,e)})),e.concatenated=(e,o="")=>r.sourceCombined(o,...e)(((e,o,...t)=>{r.give(t.join(o),e)})),e.deadline=(e,o,t)=>{let u=null;return a=>{r.value(t,r.guestCast(a,(t=>{u&&clearTimeout(u);let s=!1;u=setTimeout((()=>{s||(s=!0,r.give(new Error("Timeout reached in Deadline class"),e))}),t),r.value(r.sourceFiltered(o,(()=>!s)),a),r.value(o,r.patronOnce((()=>{s=!0})))})))}},e.deferred=(e,o)=>{const t=r.sourceResettable(r.sourceOf(),e);return r.value(o,r.patron((()=>{r.value(e,t)}))),t.value},e.dirty=(e,o=!1,t=[],u=[])=>{const a=r.sourceOf(),s=r.sourceAll([a,e]),n={give:e=>(r.give(JSON.parse(JSON.stringify(e)),a),n),value:e=>(r.value(s,r.guestCast(e,(([o,a])=>{o&&r.give(Object.fromEntries(Object.entries(o).filter((([e,r])=>!!t.includes(e)||!u.includes(e)&&r!==a[e]))),e)}))),n)};return o&&r.value(e,r.patronOnce(n)),n},e.fork=(e,o,t,u)=>{const a=r.sourceOf(),s=r.sourceOf(),n=r.sourceResettable(a,s);let l,c;return r.value(e,r.patron((e=>{s.give(1),l&&r.removePatronFromPools(l),c&&r.removePatronFromPools(c),o(e)?(l=r.patron(a),r.value(t,l)):u&&(c=r.patron(a),r.value(u,c))}))),n},e.groupActiveClass=(e,o,t)=>(r.value(r.sourceAll([e,o,t]),r.patron((([e,r,o])=>{o.forEach((r=>{r.classList&&r.classList.remove(e)})),r.classList.add(e)}))),t),e.hashTable=e=>{const o=r.sourceOf({});return r.subSource(o,e),r.value(e,r.patron((([e,r])=>{o.value((o=>{o[e]=r}))}))),o.value},e.loading=(e,o)=>{const t=r.sourceOf();return r.subSourceMany(t,[e,o]),r.value(e,r.patron((()=>{t.give(!0)}))),r.value(o,r.patron((()=>{t.give(!1)}))),t.value},e.not=e=>o=>{r.value(e,r.guestCast(o,(e=>{r.give(!e,o)})))},e.or=(e,o)=>r.sourceCombined(e,o)(((e,o,t)=>{r.give(o||t,e)})),e.path=(e,o)=>{const t=r.sourceOf();return r.subSourceMany(t,[e,o]),r.value(r.sourceAll([e,o]),r.patron((([e,o])=>{const u=o.split(".");let a=e;u.forEach((e=>{a=a[e]})),void 0!==a&&a!==e&&r.give(a,t)}))),t.value},e.record=e=>{const o=Object.keys(e);return r.sourceCombined(...Object.values(e))(((e,...t)=>{const u={};t.forEach(((e,r)=>{u[o[r]]=e})),r.give(u,e)}))},e.regexpMatch=(e,o,t="")=>r.sourceCombined(e,o,t)(((e,o,t,u)=>{const a=new RegExp(o,u).exec(t);r.give(a??[],e)})),e.regexpMatched=o,e.regexpReplaced=(e,o,t,u="")=>r.sourceCombined(o,e,t,u)(((e,o,t,u,a)=>{r.give(String(t).replace(new RegExp(o,a),u),e)})),e.router=(e,t,u)=>{const a=r.sourceOf();return r.value(t,r.patron((t=>{r.value(r.sourceAny([r.sourceChain(e,u),...t.map((t=>r.sourceChain(r.sourceFiltered(o(t.pattern,e,t.patternFlags),Boolean),t.template)))]),r.patron(a))}))),a.value},e.set=(e,o,t)=>(r.value(r.sourceAll([e,o,t]),r.patron((([e,r,o])=>{e[r]=o}))),e),e.tick=e=>{const o=r.sourceOf();r.subSource(o,e);let t=!1,u=null;return r.value(e,r.patron((e=>{u=e,t||(t=!0,queueMicrotask((()=>{t=!1,null!==u&&(r.give(u,o),u=null)})))}))),o}}({},silentium);
