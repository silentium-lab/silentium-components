!function(e,r){"use strict";const t=(e,t,a="")=>r.sourceCombined(e,t,a)(((e,t,a,s)=>{r.give(new RegExp(t,s).test(a),e)}));e.concatenated=(e,t="")=>r.sourceCombined(t,...e)(((e,t,...a)=>{r.give(a.join(t),e)})),e.deadline=(e,t,a)=>{let s=null;return u=>{r.value(a,r.guestCast(u,(a=>{s&&clearTimeout(s);let o=!1;s=setTimeout((()=>{o||(o=!0,r.give(new Error("Timeout reached in Deadline class"),e))}),a),r.value(r.sourceFiltered(t,(()=>!o)),u),r.value(t,r.patronOnce((()=>{o=!0})))})))}},e.dirty=(e,t=!1,a=[],s=[])=>{const u=r.sourceOf(),o=r.sourceAll([u,e]),n={give:e=>(r.give(JSON.parse(JSON.stringify(e)),u),n),value:e=>(r.value(o,r.guestCast(e,(([t,u])=>{t&&r.give(Object.fromEntries(Object.entries(t).filter((([e,r])=>!!a.includes(e)||!s.includes(e)&&r!==u[e]))),e)}))),n)};return t&&r.value(e,r.patronOnce(n)),n},e.groupActiveClass=(e,t,a)=>(r.value(r.sourceAll([e,t,a]),r.patron((([e,r,t])=>{t.forEach((r=>{r.classList&&r.classList.remove(e)})),r.classList.add(e)}))),a),e.hashTable=e=>{const t=r.sourceOf({});return r.subSource(t,e),r.value(e,r.patron((([e,r])=>{t.value((t=>{t[e]=r}))}))),t.value},e.loading=(e,t)=>{const a=r.sourceOf();return r.subSourceMany(a,[e,t]),r.value(e,r.patron((()=>{a.give(!0)}))),r.value(t,r.patron((()=>{a.give(!1)}))),a.value},e.path=(e,t)=>{const a=r.sourceOf();return r.subSourceMany(a,[e,t]),r.value(r.sourceAll([e,t]),r.patron((([e,t])=>{const s=t.split(".");let u=e;s.forEach((e=>{u=u[e]})),void 0!==u&&u!==e&&r.give(u,a)}))),a.value},e.record=e=>{const t=Object.keys(e);return r.sourceCombined(...Object.values(e))(((e,...a)=>{const s={};a.forEach(((e,r)=>{s[t[r]]=e})),r.give(s,e)}))},e.regexpMatched=t,e.regexpReplaced=(e,t,a,s="")=>r.sourceCombined(t,e,a,s)(((e,t,a,s,u)=>{r.give(String(a).replace(new RegExp(t,u),s),e)})),e.router=(e,a,s)=>{const u=r.sourceOf();return r.value(a,r.patron((a=>{r.value(r.sourceAny([r.sourceChain(e,s),...a.map((a=>r.sourceChain(r.sourceFiltered(t(a.pattern,e,a.patternFlags),Boolean),a.template)))]),r.patron(u))}))),u.value}}({},silentium);
