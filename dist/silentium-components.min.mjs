import{primitive as e,shared as t,filtered as r,isFilled as n,late as l,applied as i,all as o,executorApplied as c,of as s,destructor as a}from"silentium";const u=(t,r,n)=>l=>{const i=e(r);let o;void 0!==n&&(o=e(n)),t((e=>{let t=null;e?t=i.primitive():o&&(t=o.primitive()),null!==t&&l(t)}))},v=(e,t)=>r=>{t((()=>{r(e)}))},p=(e,n,l)=>i=>{let o=null;const c=t(n,!0);l((t=>{o&&clearTimeout(o);let n=!1;o=setTimeout((()=>{n||(n=!0,e(new Error("Timeout reached in Deadline class")))}),t);r(c.value,(()=>!n))(i),c.value((()=>{n=!0}))}))},m=(t,r)=>l=>{const i=e(t);r((()=>{const e=i.primitive();n(e)&&l(e)}))},f=t=>{const r=e(t);let l=r.primitive();return function e(t){n(l)?t(l):(l=r.primitive(),e(t))}},g=(e,t=[],r=[],n)=>{const c=l();return void 0===n&&(n=e=>JSON.parse(JSON.stringify(e))),{value:l=>{const s=i(c.value,n);o(s,e)((([e,n])=>{e&&l(Object.fromEntries(Object.entries(e).filter((([e,l])=>!!t.includes(e)||!r.includes(e)&&l!==n[e]))))}))},give:e=>{c.give(e)}}},d=(e,t)=>r=>{e((()=>r(!0))),t((()=>r(!1)))},E=(e,t)=>n=>{let l=!1;t((e=>{l=e}));r(e,(()=>!l))(n)},h=e=>t=>{let r=null;e((e=>{e!==r&&(t(e),r=e)}))},O=e=>t=>{let r=!1;e((e=>{!1===r?r=!0:t(e)}))},S=(t,r)=>{const l=e(t.value),i=e(r);return{value:e=>{o(t.value,r)((([t,r])=>{const n=r.split(".");let l=t;n.forEach((e=>{l=l[e]})),void 0!==l&&l!==t&&e(l)}))},give:e=>{const r=i.primitive();n(r)&&t.give({...l.primitive(),[r]:e})}}},j=(e,t)=>r=>{o(e,t)((([e,t])=>{const n=t.split(".");let l=e;n.forEach((e=>{l=l[e]})),void 0!==l&&l!==e&&r(l)}))},y=(e,t)=>r=>{t((()=>{e(r)}))},T=(t,r)=>l=>{const i=e(t);r((()=>{const e=i.primitive();n(e)&&l(e)}))},b=(e,t=0)=>r=>{let n=null;c(e,(e=>r=>{n&&clearTimeout(n),n=setTimeout((()=>{e(r)}),t)}))(r)},w=e=>t=>{let r=!1,n=null;e((e=>{n=e,r||(r=!0,queueMicrotask((()=>{r=!1,null!==n&&(t(n),n=null)})))}))},J=e=>t=>{const r={};e((([e,n])=>{r[e]=n,t(r)}))},N=e=>t=>{const r=Object.keys(e);o(...Object.values(e))((e=>{const n={};e.forEach(((e,t)=>{n[r[t]]=e})),t(n)}))},x=(e,t=s(""))=>r=>{o(t,...e)((([e,...t])=>{r(t.join(e))}))},$=(e=s(""),t=s({}))=>{let r=0;const n={$TPL:s("$TPL")},l=[];return{value:r=>{const l=N(n);i(o(e,t,l),(([e,t,r])=>(Object.entries(t).forEach((([t,r])=>{e=e.replaceAll(t,String(r))})),Object.entries(r).forEach((([t,r])=>{e=e.replaceAll(t,String(r))})),e)))(r)},template:t=>{e=s(t)},var:e=>{const t=`$var${r}`;return r+=1,n[t]=a(e,(e=>{l.push(e)})).value,t},destroy(){l.forEach((e=>e()))}}},F=(e,t,r=s(""))=>n=>{o(e,t,r)((([e,t,r])=>{n(new RegExp(e,r).test(t))}))},R=(e,t,r,n=s(""))=>l=>{o(t,e,r,n)((([e,t,r,n])=>{l(String(t).replace(new RegExp(e,n),r))}))},k=(e,t,r=s(""))=>n=>{o(e,t,r)((([e,t,r])=>{const l=new RegExp(e,r).exec(t);n(l??[])}))},A=(e,t,r)=>n=>{o(e,t,r)((([e,t,r])=>{e[t]=r,n(e)}))},L=()=>s(!1),P=(e,t,r)=>n=>{const l=[],c=()=>{l.forEach((e=>e())),l.length=0};return o(t,e)((([e,t])=>{c();const u=o(r(),o(...e.map((e=>{return a((r=F(s(e.pattern),s(t),e.patternFlags?s(e.patternFlags):void 0),n=e.template,i=L,e=>{let t;return r((r=>{void 0!==t&&"function"==typeof t&&t();let l=null;r?l=n():i&&(l=i()),l&&(t=l(e))})),()=>{t?.()}}),(e=>l.push(e))).value;var r,n,i}))));i(u,(e=>{const t=e[1].find((e=>!1!==e));return t||e[0]}))(n)})),c},q=(e,t)=>r=>{o(e,t)((([e,t])=>{r(e&&t)}))},B=(e,t)=>r=>{o(e,t)((([e,t])=>{r(e||t)}))},D=e=>t=>{e((e=>{t(!e)}))},M=e=>t=>{i(e,Boolean)(t)},z=(e,t)=>r=>{e((e=>{try{r(JSON.parse(e))}catch(e){t?.(new Error(`Failed to parse JSON: ${e}`))}}))},C=(e,t)=>r=>{e((e=>{try{r(JSON.stringify(e))}catch{t?.(new Error("Failed to convert to JSON"))}}))},G=e=>t=>{i(e,(e=>e[0]))(t)};export{q as and,M as bool,u as branch,x as concatenated,v as constant,p as deadline,m as deferred,f as detached,g as dirty,G as first,z as fromJson,J as hashTable,d as loading,E as lock,h as memo,D as not,O as onlyChanged,B as or,S as part,j as path,y as polling,N as recordOf,k as regexpMatch,F as regexpMatched,R as regexpReplaced,P as router,A as set,T as shot,b as task,$ as template,w as tick,C as toJson};
//# sourceMappingURL=silentium-components.min.mjs.map
