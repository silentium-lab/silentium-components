import{value as e,sourceAll as t,patron as n,sourceOf as l,patronOnce as r,guestCast as u,give as s,subSourceMany as c,sourceFiltered as o,subSource as a,sourceResettable as i,removePatronFromPools as v,guestDisposable as g,destroy as p,guestSync as m,sourceSync as d,source as E,sourceCombined as f,sourceAny as O,sourceChain as j}from"silentium";const x=(l,r,u)=>(e(t([l,r,u]),n((([e,t,n])=>{n.forEach((t=>{t.classList&&t.classList.remove(e)})),t.classList.add(e)}))),u),y=(n,c=!1,o=[],a=[])=>{const i=l(),v=t([i,n]),g={give:e=>(s(JSON.parse(JSON.stringify(e)),i),g),value:t=>(e(v,u(t,(([e,n])=>{e&&s(Object.fromEntries(Object.entries(e).filter((([e,t])=>!!o.includes(e)||!a.includes(e)&&t!==n[e]))),t)}))),g)};return c&&e(n,r(g)),g},b=(t,r)=>{const u=l();return c(u,[t,r]),e(t,n((()=>{u.give(!0)}))),e(r,n((()=>{u.give(!1)}))),u.value},h=(r,u)=>{const o=l();return c(o,[r,u]),e(t([r,u]),n((([e,t])=>{const n=t.split(".");let l=e;n.forEach((e=>{l=l[e]})),void 0!==l&&l!==e&&s(l,o)}))),o.value},w=(t,n,l)=>{let c=null;return a=>{e(l,u(a,(l=>{c&&clearTimeout(c);let u=!1;c=setTimeout((()=>{u||(u=!0,s(new Error("Timeout reached in Deadline class"),t))}),l),e(o(n,(()=>!u)),a),e(n,r((()=>{u=!0})))})))}},L=t=>{const r=l();a(r,t);let u=!1,c=null;return e(t,n((e=>{c=e,u||(u=!0,queueMicrotask((()=>{u=!1,null!==c&&(s(c,r),c=null)})))}))),r},R=(t,u,s,c)=>{const o=l(),a=l(),g=i(o,a);let p,m;return e(t,n((t=>{a.give(1),p&&v(p),m&&v(m),u(t)?(p=r(o),e(s,p)):c&&(m=r(o),e(c,m))}))),g},S=(t,r)=>{const u=i(l(),t);return e(r,n((()=>{e(t,u)}))),u.value},T=(t,u,s)=>{const c=l();return e(t,n((t=>{!0===t?e(u,r((e=>{c.give(e)}))):void 0!==s&&e(s,r((e=>{c.give(e)})))}))),c.value},V=t=>{const r=l();let u=null;return e(t,n((e=>{e!==u&&(r.give(e),u=e)}))),r.value},k=(t,u)=>{const s=l(),c=i(s,u);let o=!1;return a(s,t),e(t,n(g(s.give,(()=>o)))),e(u,r((()=>{o=!0,p([s])}))),c.value},J=(t,n)=>{const l=m(n);return e(t,l),e=>{s(l.value(),e)}},N=(t,r)=>{const u=l(),s=l(),c=d(t,null);return e(r,n((()=>{null!==c.syncValue()&&(s.give(c.syncValue()),u.give(1))}))),i(s,u)},q=t=>{let n=d(t,null).syncValue();return E((l=>{e(t,u(l,(e=>{null===n?n=e:n!==e&&s(e,l)})))}))},B=t=>{const r=l({});return a(r,t),e(t,n((([e,t])=>{r.value((n=>{n[e]=t}))}))),r.value},D=e=>{const t=Object.keys(e);return f(...Object.values(e))(((e,...n)=>{const l={};n.forEach(((e,n)=>{l[t[n]]=e})),s(l,e)}))},F=(e,t="")=>f(t,...e)(((e,t,...n)=>{s(n.join(t),e)})),M=(e,t,n="")=>f(e,t,n)(((e,t,n,l)=>{s(new RegExp(t,l).test(n),e)})),z=(t,r,u)=>{const s=l();return e(r,n((l=>{e(O([j(t,u),...l.map((e=>j(o(M(e.pattern,t,e.patternFlags),Boolean),e.template)))]),n(s))}))),s.value},A=(e,t,n,l="")=>f(t,e,n,l)(((e,t,n,l,r)=>{s(String(n).replace(new RegExp(t,r),l),e)})),C=(e,t,n="")=>f(e,t,n)(((e,t,n,l)=>{const r=new RegExp(t,l).exec(n);s(r??[],e)})),G=(l,r,u)=>(e(t([l,r,u]),n((([e,t,n])=>{e[t]=n}))),l),H=(e,t)=>f(e,t)(((e,t,n)=>{s(t&&n,e)})),I=(e,t)=>f(e,t)(((e,t,n)=>{s(t||n,e)})),K=t=>n=>{e(t,u(n,(e=>{s(!e,n)})))};export{H as and,T as branch,F as concatenated,w as deadline,S as deferred,y as dirty,R as fork,x as groupActiveClass,B as hashTable,b as loading,k as lock,V as memo,J as moment,K as not,q as onlyChanged,I as or,h as path,D as record,C as regexpMatch,M as regexpMatched,A as regexpReplaced,z as router,G as set,N as shot,L as tick};
//# sourceMappingURL=silentium-components.min.mjs.map
