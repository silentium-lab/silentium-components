import{value as e,sourceAll as t,systemPatron as n,sourceOf as r,patronOnce as l,guestCast as s,give as u,subSourceMany as c,sourceFiltered as o,subSource as i,sourceResettable as a,removePatronFromPools as v,firstVisit as g,guestDisposable as p,destroy as m,guestSync as E,sourceSync as d,source as f,sourceCombined as O,sourceChain as h}from"silentium";const j=(r,l,s)=>(e(t([r,l,s]),n((([e,t,n])=>{n.forEach((t=>{t.classList&&t.classList.remove(e)})),t.classList.add(e)}))),s),x=(n,c=!1,o=[],i=[])=>{const a=r(),v=t([a,n]),g={give:e=>(u(JSON.parse(JSON.stringify(e)),a),g),value:t=>(e(v,s(t,(([e,n])=>{e&&u(Object.fromEntries(Object.entries(e).filter((([e,t])=>!!o.includes(e)||!i.includes(e)&&t!==n[e]))),t)}))),g)};return c&&e(n,l(g)),g},b=(t,l)=>{const s=r();return c(s,[t,l]),e(t,n((()=>{s.give(!0)}))),e(l,n((()=>{s.give(!1)}))),s.value},w=(l,s)=>{const o=r();return c(o,[l,s]),e(t([l,s]),n((([e,t])=>{const n=t.split(".");let r=e;n.forEach((e=>{r=r[e]})),void 0!==r&&r!==e&&u(r,o)}))),o.value},y=(t,n,r)=>{let c=null;return i=>{e(r,s(i,(r=>{c&&clearTimeout(c);let s=!1;c=setTimeout((()=>{s||(s=!0,u(new Error("Timeout reached in Deadline class"),t))}),r),e(o(n,(()=>!s)),i),e(n,l((()=>{s=!0})))})))}},L=t=>{const l=r();i(l,t);let s=!1,c=null;return e(t,n((e=>{c=e,s||(s=!0,queueMicrotask((()=>{s=!1,null!==c&&(u(c,l),c=null)})))}))),l},R=(t,s,u,c)=>{const o=r(),i=r(),g=a(o,i);let p,m;return e(t,n((t=>{i.give(1),p&&v(p),m&&v(m),s(t)?(p=l(o),e(u,p)):c&&(m=l(o),e(c,m))}))),g},S=(t,l)=>{const s=a(r(),t),u=g((()=>{e(l,n((()=>{e(t,s)})))}));return t=>{u(),e(s,t)}},T=(t,s,u)=>{const c=r(),o=r(),i=a(o,c),v=g((()=>{e(t,n((t=>{c.give(1),!0===t?e(s,l((e=>{o.give(e)}))):void 0!==u&&e(u,l((e=>{o.give(e)})))})))}));return e=>{v(),i.value(e)}},k=t=>{const l=r();let s=null;return e(t,n((e=>{e!==s&&(l.give(e),s=e)}))),l.value},J=(t,s)=>{const u=r(),c=a(u,s);let o=!1;return i(u,t),e(t,n(p(u.give,(()=>o)))),e(s,l((()=>{o=!0,m([u])}))),c},N=(t,n)=>{const r=E(n);return e(t,r),e=>{u(r.value(),e)}},V=(t,l)=>{const s=r(),u=r(),c=d(t,null);return e(l,n((()=>{null!==c.syncValue()&&(u.give(c.syncValue()),s.give(1))}))),a(u,s)},q=t=>{let n=!1;return f((r=>{e(t,s(r,(e=>{!1===n?n=!0:u(e,r)})))}))},D=t=>{const l=r({});return i(l,t),e(t,n((([e,t])=>{l.value((n=>{n[e]=t}))}))),l.value},F=e=>{const t=Object.keys(e);return O(...Object.values(e))(((e,...n)=>{const r={};n.forEach(((e,n)=>{r[t[n]]=e})),u(r,e)}))},M=(e,t="")=>O(t,...e)(((e,t,...n)=>{u(n.join(t),e)})),z=(t,l)=>{const s=r();let c=0;const o=g((()=>{e(l,n((()=>{c=0,t.forEach(((t,n)=>{e(t,(e=>{((e,t)=>{c<=t&&(c=t,u(e,s))})(e,n)}))}))})))}));return e=>{o(),s.value(e)}},A=(e,t,n="")=>O(e,t,n)(((e,t,n,r)=>{u(new RegExp(t,r).test(n),e)})),B=(t,l,s)=>{const u=r();return e(l,n((r=>{e(z([h(t,s),...r.map((r=>e(T(A(r.pattern,t,r.patternFlags),r.template),n((e=>e)))))],t),[n(u),e=>e])}))),u.value},C=(e,t,n,r="")=>O(t,e,n,r)(((e,t,n,r,l)=>{u(String(n).replace(new RegExp(t,l),r),e)})),G=(e,t,n="")=>O(e,t,n)(((e,t,n,r)=>{const l=new RegExp(t,r).exec(n);u(l??[],e)})),H=(r,l,s)=>(e(t([r,l,s]),n((([e,t,n])=>{e[t]=n}))),r),I=(e,t)=>O(e,t)(((e,t,n)=>{u(t&&n,e)})),K=(e,t)=>O(e,t)(((e,t,n)=>{u(t||n,e)})),P=t=>n=>{e(t,s(n,(e=>{u(!e,n)})))};export{I as and,T as branch,M as concatenated,y as deadline,S as deferred,x as dirty,R as fork,j as groupActiveClass,D as hashTable,b as loading,J as lock,k as memo,N as moment,P as not,q as onlyChanged,K as or,w as path,F as record,G as regexpMatch,A as regexpMatched,C as regexpReplaced,B as router,H as set,V as shot,L as tick};
//# sourceMappingURL=silentium-components.min.mjs.map
