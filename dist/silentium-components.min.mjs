import{value as e,sourceAll as t,patron as r,sourceOf as s,patronOnce as n,guestCast as l,give as a,subSourceMany as o,sourceFiltered as c,subSource as i,sourceCombined as u,sourceAny as v,sourceChain as m}from"silentium";const p=(s,n,l)=>(e(t([s,n,l]),r((([e,t,r])=>{r.forEach((t=>{t.classList&&t.classList.remove(e)})),t.classList.add(e)}))),l),d=(r,o=!1,c=[],i=[])=>{const u=s(),v=t([u,r]),m={give:e=>(a(JSON.parse(JSON.stringify(e)),u),m),value:t=>(e(v,l(t,(([e,r])=>{e&&a(Object.fromEntries(Object.entries(e).filter((([e,t])=>!!c.includes(e)||!i.includes(e)&&t!==r[e]))),t)}))),m)};return o&&e(r,n(m)),m},f=(t,n)=>{const l=s();return o(l,[t,n]),e(t,r((()=>{l.give(!0)}))),e(n,r((()=>{l.give(!1)}))),l.value},g=(n,l)=>{const c=s();return o(c,[n,l]),e(t([n,l]),r((([e,t])=>{const r=t.split(".");let s=e;r.forEach((e=>{s=s[e]})),void 0!==s&&s!==e&&a(s,c)}))),c.value},E=(t,r,s)=>{let o=null;return i=>{e(s,l(i,(s=>{o&&clearTimeout(o);let l=!1;o=setTimeout((()=>{l||(l=!0,a(new Error("Timeout reached in Deadline class"),t))}),s),e(c(r,(()=>!l)),i),e(r,n((()=>{l=!0})))})))}},O=t=>{const n=s({});return i(n,t),e(t,r((([e,t])=>{n.value((r=>{r[e]=t}))}))),n.value},j=e=>{const t=Object.keys(e);return u(...Object.values(e))(((e,...r)=>{const s={};r.forEach(((e,r)=>{s[t[r]]=e})),a(s,e)}))},b=(e,t="")=>u(t,...e)(((e,t,...r)=>{a(r.join(t),e)})),h=(t,n,l)=>{const o=s();return e(n,r((s=>{e(v([m(t,l),...s.map((e=>m(c(((e,t,r="")=>u(e,t,r)(((e,t,r,s)=>{a(new RegExp(t,s).test(r),e)})))(e.pattern,t,e.patternFlags),Boolean),e.template)))]),r(o))}))),o.value};export{b as concatenated,E as deadline,d as dirty,p as groupActiveClass,O as hashTable,f as loading,g as path,j as record,h as router};
//# sourceMappingURL=silentium-components.min.mjs.map
