import{value as e,sourceAll as t,patron as n,sourceOf as r,patronOnce as s,guestCast as l,give as c,subSourceMany as o,sourceFiltered as u,subSource as a,sourceResettable as i,removePatronFromPools as v,sourceCombined as p,sourceAny as g,sourceChain as m}from"silentium";const E=(r,s,l)=>(e(t([r,s,l]),n((([e,t,n])=>{n.forEach((t=>{t.classList&&t.classList.remove(e)})),t.classList.add(e)}))),l),d=(n,o=!1,u=[],a=[])=>{const i=r(),v=t([i,n]),p={give:e=>(c(JSON.parse(JSON.stringify(e)),i),p),value:t=>(e(v,l(t,(([e,n])=>{e&&c(Object.fromEntries(Object.entries(e).filter((([e,t])=>!!u.includes(e)||!a.includes(e)&&t!==n[e]))),t)}))),p)};return o&&e(n,s(p)),p},f=(t,s)=>{const l=r();return o(l,[t,s]),e(t,n((()=>{l.give(!0)}))),e(s,n((()=>{l.give(!1)}))),l.value},O=(s,l)=>{const u=r();return o(u,[s,l]),e(t([s,l]),n((([e,t])=>{const n=t.split(".");let r=e;n.forEach((e=>{r=r[e]})),void 0!==r&&r!==e&&c(r,u)}))),u.value},j=(t,n,r)=>{let o=null;return a=>{e(r,l(a,(r=>{o&&clearTimeout(o);let l=!1;o=setTimeout((()=>{l||(l=!0,c(new Error("Timeout reached in Deadline class"),t))}),r),e(u(n,(()=>!l)),a),e(n,s((()=>{l=!0})))})))}},x=t=>{const s=r();a(s,t);let l=!1,o=null;return e(t,n((e=>{o=e,l||(l=!0,queueMicrotask((()=>{l=!1,null!==o&&(c(o,s),o=null)})))}))),s},b=(t,s,l,c)=>{const o=r(),u=r(),a=i(o,u);let p,g;return e(t,n((t=>{u.give(1),p&&v(p),g&&v(g),s(t)?(p=n(o),e(l,p)):c&&(g=n(o),e(c,g))}))),a},h=t=>{const s=r({});return a(s,t),e(t,n((([e,t])=>{s.value((n=>{n[e]=t}))}))),s.value},w=e=>{const t=Object.keys(e);return p(...Object.values(e))(((e,...n)=>{const r={};n.forEach(((e,n)=>{r[t[n]]=e})),c(r,e)}))},L=(e,t="")=>p(t,...e)(((e,t,...n)=>{c(n.join(t),e)})),R=(e,t,n="")=>p(e,t,n)(((e,t,n,r)=>{c(new RegExp(t,r).test(n),e)})),S=(t,s,l)=>{const c=r();return e(s,n((r=>{e(g([m(t,l),...r.map((e=>m(u(R(e.pattern,t,e.patternFlags),Boolean),e.template)))]),n(c))}))),c.value},T=(e,t,n,r="")=>p(t,e,n,r)(((e,t,n,r,s)=>{c(String(n).replace(new RegExp(t,s),r),e)})),k=(e,t,n="")=>p(e,t,n)(((e,t,n,r)=>{const s=new RegExp(t,r).exec(n);c(s??[],e)})),y=(e,t)=>p(e,t)(((e,t,n)=>{c(t&&n,e)})),J=(e,t)=>p(e,t)(((e,t,n)=>{c(t||n,e)})),N=t=>n=>{e(t,l(n,(e=>{c(!e,n)})))};export{y as and,L as concatenated,j as deadline,d as dirty,b as fork,E as groupActiveClass,h as hashTable,f as loading,N as not,J as or,O as path,w as record,k as regexpMatch,R as regexpMatched,T as regexpReplaced,S as router,x as tick};
//# sourceMappingURL=silentium-components.min.mjs.map
