import{value as e,sourceAll as t,patron as r,sourceOf as n,patronOnce as s,guestCast as l,give as a,subSourceMany as c,sourceFiltered as i,subSource as o,sourceCombined as u,sourceAny as v,sourceChain as p}from"silentium";const m=(n,s,l)=>(e(t([n,s,l]),r((([e,t,r])=>{r.forEach((t=>{t.classList&&t.classList.remove(e)})),t.classList.add(e)}))),l),g=(r,c=!1,i=[],o=[])=>{const u=n(),v=t([u,r]),p={give:e=>(a(JSON.parse(JSON.stringify(e)),u),p),value:t=>(e(v,l(t,(([e,r])=>{e&&a(Object.fromEntries(Object.entries(e).filter((([e,t])=>!!i.includes(e)||!o.includes(e)&&t!==r[e]))),t)}))),p)};return c&&e(r,s(p)),p},d=(t,s)=>{const l=n();return c(l,[t,s]),e(t,r((()=>{l.give(!0)}))),e(s,r((()=>{l.give(!1)}))),l.value},f=(s,l)=>{const i=n();return c(i,[s,l]),e(t([s,l]),r((([e,t])=>{const r=t.split(".");let n=e;r.forEach((e=>{n=n[e]})),void 0!==n&&n!==e&&a(n,i)}))),i.value},E=(t,r,n)=>{let c=null;return o=>{e(n,l(o,(n=>{c&&clearTimeout(c);let l=!1;c=setTimeout((()=>{l||(l=!0,a(new Error("Timeout reached in Deadline class"),t))}),n),e(i(r,(()=>!l)),o),e(r,s((()=>{l=!0})))})))}},O=t=>{const s=n({});return o(s,t),e(t,r((([e,t])=>{s.value((r=>{r[e]=t}))}))),s.value},j=e=>{const t=Object.keys(e);return u(...Object.values(e))(((e,...r)=>{const n={};r.forEach(((e,r)=>{n[t[r]]=e})),a(n,e)}))},b=(e,t="")=>u(t,...e)(((e,t,...r)=>{a(r.join(t),e)})),h=(e,t,r="")=>u(e,t,r)(((e,t,r,n)=>{a(new RegExp(t,n).test(r),e)})),w=(t,s,l)=>{const a=n();return e(s,r((n=>{e(v([p(t,l),...n.map((e=>p(i(h(e.pattern,t,e.patternFlags),Boolean),e.template)))]),r(a))}))),a.value},x=(e,t,r,n="")=>u(t,e,r,n)(((e,t,r,n,s)=>{a(String(r).replace(new RegExp(t,s),n),e)}));export{b as concatenated,E as deadline,g as dirty,m as groupActiveClass,O as hashTable,d as loading,f as path,j as record,h as regexpMatched,x as regexpReplaced,w as router};
//# sourceMappingURL=silentium-components.min.mjs.map
