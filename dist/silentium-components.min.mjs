import{value as e,sourceAll as t,patron as r,sourceOf as s,patronOnce as i,guestCast as l,give as n,subSourceMany as c,sourceFiltered as o,subSource as u}from"silentium";const a=(s,i,l)=>(e(t([s,i,l]),r((([e,t,r])=>{r.forEach((t=>{t.classList&&t.classList.remove(e)})),t.classList.add(e)}))),l),v=(r,c=!1,o=[],u=[])=>{const a=s(),v=t([a,r]),m={give:e=>(n(JSON.parse(JSON.stringify(e)),a),m),value:t=>(e(v,l(t,(([e,r])=>{e&&n(Object.fromEntries(Object.entries(e).filter((([e,t])=>!!o.includes(e)||!u.includes(e)&&t!==r[e]))),t)}))),m)};return c&&e(r,i(m)),m},m=(t,i)=>{const l=s();return c(l,[t,i]),e(t,r((()=>{l.give(!0)}))),e(i,r((()=>{l.give(!1)}))),l.value},d=(i,l)=>{const o=s();return c(o,[i,l]),e(t([i,l]),r((([e,t])=>{const r=t.split(".");let s=e;r.forEach((e=>{s=s[e]})),void 0!==s&&s!==e&&n(s,o)}))),o.value},f=(t,r,s)=>{let c=null;return u=>{e(s,l(u,(s=>{c&&clearTimeout(c);let l=!1;c=setTimeout((()=>{l||(l=!0,n(new Error("Timeout reached in Deadline class"),t))}),s),e(o(r,(()=>!l)),u),e(r,i((()=>{l=!0})))})))}},g=t=>{const i=s({});return u(i,t),e(t,r((([e,t])=>{i.value((r=>{r[e]=t}))}))),i.value};export{f as deadline,v as dirty,a as groupActiveClass,g as hashTable,m as loading,d as path};
//# sourceMappingURL=silentium-components.min.mjs.map
