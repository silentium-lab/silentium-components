import{value as e,sourceAll as t,systemPatron as n,sourceOf as r,patronOnce as l,guestCast as s,give as u,subSourceMany as c,sourceFiltered as o,subSource as i,sourceResettable as a,removePatronFromPools as v,firstVisit as g,guestDisposable as p,destroy as m,guestSync as d,sourceSync as E,source as f,sourceCombined as O}from"silentium";const h=(r,l,s)=>(e(t([r,l,s]),n((([e,t,n])=>{n.forEach((t=>{t.classList&&t.classList.remove(e)})),t.classList.add(e)}))),s),j=(n,c=!1,o=[],i=[])=>{const a=r(),v=t([a,n]),g={give:e=>(u(JSON.parse(JSON.stringify(e)),a),g),value:t=>(e(v,s(t,(([e,n])=>{e&&u(Object.fromEntries(Object.entries(e).filter((([e,t])=>!!o.includes(e)||!i.includes(e)&&t!==n[e]))),t)}))),g)};return c&&e(n,l(g)),g},x=(t,l)=>{const s=r();return c(s,[t,l]),e(t,n((()=>{s.give(!0)}))),e(l,n((()=>{s.give(!1)}))),s.value},b=(l,s)=>{const o=r();return c(o,[l,s]),e(t([l,s]),n((([e,t])=>{const n=t.split(".");let r=e;n.forEach((e=>{r=r[e]})),void 0!==r&&r!==e&&u(r,o)}))),o.value},w=(t,n,r)=>{let c=null;return i=>{e(r,s(i,(r=>{c&&clearTimeout(c);let s=!1;c=setTimeout((()=>{s||(s=!0,u(new Error("Timeout reached in Deadline class"),t))}),r),e(o(n,(()=>!s)),i),e(n,l((()=>{s=!0})))})))}},y=t=>{const l=r();i(l,t);let s=!1,c=null;return e(t,n((e=>{c=e,s||(s=!0,queueMicrotask((()=>{s=!1,null!==c&&(u(c,l),c=null)})))}))),l},L=(t,s,u,c)=>{const o=r(),i=r(),g=a(o,i);let p,m;return e(t,n((t=>{i.give(1),p&&v(p),m&&v(m),s(t)?(p=l(o),e(u,p)):c&&(m=l(o),e(c,m))}))),g},R=(t,l)=>{const s=a(r(),t),u=g((()=>{e(l,n((()=>{e(t,s)})))}));return t=>{u(),e(s,t)}},S=(t,s,u)=>{const c=r(),o=r(),i=a(o,c),v=g((()=>{e(t,n((t=>{c.give(1),!0===t?e(s,l(o.give)):void 0!==u&&e(u,l(o.give))})))}));return e=>{v(),i.value(e)}},T=t=>{const l=r();let s=null;return e(t,n((e=>{e!==s&&(l.give(e),s=e)}))),l.value},k=(t,s)=>{const u=r(),c=a(u,s);let o=!1;return i(u,t),e(t,n(p(u.give,(()=>o)))),e(s,l((()=>{o=!0,m([u])}))),c},J=(t,n)=>{const r=d(n);return e(t,r),e=>{u(r.value(),e)}},N=(t,l)=>{const s=r(),u=r(),c=E(t,null);return e(l,n((()=>{null!==c.syncValue()&&(u.give(c.syncValue()),s.give(1))}))),a(u,s)},V=t=>{let n=!1;return f((r=>{e(t,s(r,(e=>{!1===n?n=!0:u(e,r)})))}))},q=t=>{const l=r({});return i(l,t),e(t,n((([e,t])=>{l.value((n=>{n[e]=t}))}))),l.value},D=e=>{const t=Object.keys(e);return O(...Object.values(e))(((e,...n)=>{const r={};n.forEach(((e,n)=>{r[t[n]]=e})),u(r,e)}))},F=(e,t="")=>O(t,...e)(((e,t,...n)=>{u(n.join(t),e)})),M=(e,t,n="")=>O(e,t,n)(((e,t,n,r)=>{u(new RegExp(t,r).test(n),e)})),z=(t,s,c)=>{const o=r(),i=g((()=>{e(s,l((l=>{const s=(i=[c,...l.map((r=>e(S(M(r.pattern,t,r.patternFlags),r.template),n((e=>e)))))],t=>{let n,r=0;i.forEach(((t,l)=>{e(t,(e=>{r<=l&&(r=l,n=e)}))})),void 0!==n&&u(n,t)});var i;const a=((t,l)=>{const s=r(),u=g((()=>{e(l,n((()=>{e(t,s)})))}));return e=>{u(),s.value(e)}})(s,t);e(a,n(o))})))}));return e=>{i(),o.value(e)}},A=(e,t,n,r="")=>O(t,e,n,r)(((e,t,n,r,l)=>{u(String(n).replace(new RegExp(t,l),r),e)})),B=(e,t,n="")=>O(e,t,n)(((e,t,n,r)=>{const l=new RegExp(t,r).exec(n);u(l??[],e)})),C=(r,l,s)=>(e(t([r,l,s]),n((([e,t,n])=>{e[t]=n}))),r),G=(e,t)=>O(e,t)(((e,t,n)=>{u(t&&n,e)})),H=(e,t)=>O(e,t)(((e,t,n)=>{u(t||n,e)})),I=t=>n=>{e(t,s(n,(e=>{u(!e,n)})))};export{G as and,S as branch,F as concatenated,w as deadline,R as deferred,j as dirty,L as fork,h as groupActiveClass,q as hashTable,x as loading,k as lock,T as memo,J as moment,I as not,V as onlyChanged,H as or,b as path,D as record,B as regexpMatch,M as regexpMatched,A as regexpReplaced,z as router,C as set,N as shot,y as tick};
//# sourceMappingURL=silentium-components.min.mjs.map
