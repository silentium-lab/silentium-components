import{primitive as e,shared as t,filtered as n,isFilled as l,late as r,applied as i,all as o,executorApplied as c,of as s}from"silentium";const a=(t,n,l)=>r=>{const i=e(n);let o;void 0!==l&&(o=e(l)),t((e=>{let t=null;e?t=i.primitive():o&&(t=o.primitive()),null!==t&&r(t)}))},u=(e,t)=>n=>{t((()=>{n(e)}))},v=(e,l,r)=>i=>{let o=null;const c=t(l,!0);r((t=>{o&&clearTimeout(o);let l=!1;o=setTimeout((()=>{l||(l=!0,e(new Error("Timeout reached in Deadline class")))}),t);n(c.value,(()=>!l))(i),c.value((()=>{l=!0}))}))},p=(t,n)=>r=>{const i=e(t);n((()=>{const e=i.primitive();l(e)&&r(e)}))},m=(e,t=[],n=[],l)=>{const c=r();return void 0===l&&(l=e=>JSON.parse(JSON.stringify(e))),{value:r=>{const s=i(c.value,l);o(s,e)((([e,l])=>{e&&r(Object.fromEntries(Object.entries(e).filter((([e,r])=>!!t.includes(e)||!n.includes(e)&&r!==l[e]))))}))},give:e=>{c.give(e)}}},g=(e,t)=>n=>{e((()=>n(!0))),t((()=>n(!1)))},d=(e,t)=>l=>{let r=!1;t((e=>{r=e}));n(e,(()=>!r))(l)},f=e=>t=>{let n=null;e((e=>{e!==n&&(t(e),n=e)}))},E=e=>t=>{let n=!1;e((e=>{!1===n?n=!0:t(e)}))},O=(t,n)=>{const r=e(t.value),i=e(n);return{value:e=>{o(t.value,n)((([t,n])=>{const l=n.split(".");let r=t;l.forEach((e=>{r=r[e]})),void 0!==r&&r!==t&&e(r)}))},give:e=>{const n=i.primitive();l(n)&&t.give({...r.primitive(),[n]:e})}}},S=(e,t)=>n=>{o(e,t)((([e,t])=>{const l=t.split(".");let r=e;l.forEach((e=>{r=r[e]})),void 0!==r&&r!==e&&n(r)}))},h=(e,t)=>n=>{t((()=>{e(n)}))},j=(t,n)=>r=>{const i=e(t);n((()=>{const e=i.primitive();l(e)&&r(e)}))},T=e=>t=>{let n=!1,l=null;e((e=>{l=e,n||(n=!0,queueMicrotask((()=>{n=!1,null!==l&&(t(l),l=null)})))}))},b=(e,t=0)=>n=>{let l=null;c(e,(e=>n=>{l&&clearTimeout(l),l=setTimeout((()=>{e(n)}),t)}))(n)},w=e=>t=>{const n={};e((([e,l])=>{n[e]=l,t(n)}))},y=e=>t=>{const n=Object.keys(e);o(...Object.values(e))((e=>{const l={};e.forEach(((e,t)=>{l[n[t]]=e})),t(l)}))},J=(e,t=s(""))=>n=>{o(t,...e)((([e,...t])=>{n(t.join(e))}))},N=(e=s(""),t=s({}))=>{let n=0;const l={$TPL:s("$TPL")};return{value:n=>{const r=y(l);i(o(e,t,r),(([e,t,n])=>(Object.entries(t).forEach((([t,n])=>{e=e.replaceAll(t,String(n))})),Object.entries(n).forEach((([t,n])=>{e=e.replaceAll(t,String(n))})),e)))(n)},template:t=>{e=s(t)},var:e=>{const t=`$var${n}`;return n+=1,l[t]=e,t}}},x=(e,t,n=s(""))=>l=>{o(e,t,n)((([e,t,n])=>{l(new RegExp(e,n).test(t))}))},$=(e,t,n,l=s(""))=>r=>{o(t,e,n,l)((([e,t,n,l])=>{r(String(t).replace(new RegExp(e,l),n))}))},F=(e,t,n=s(""))=>l=>{o(e,t,n)((([e,t,n])=>{const r=new RegExp(e,n).exec(t);l(r??[])}))},R=(e,t,n)=>l=>{o(e,t,n)((([e,t,n])=>{e[t]=n,l(e)}))},k=()=>s(!1),A=(e,t,n)=>l=>{o(t,e)((([e,t])=>{const r=o(n(),o(...e.map((e=>{return n=x(s(e.pattern),s(t),e.patternFlags?s(e.patternFlags):void 0),l=e.template,r=k,e=>{let t;n((n=>{void 0!==t&&"function"==typeof t&&t();let i=null;n?i=l():r&&(i=r()),i&&(t=i(e))}))};var n,l,r}))));i(r,(e=>{const t=e[1].find((e=>!1!==e));return t||e[0]}))(l)}))},L=(e,t)=>n=>{o(e,t)((([e,t])=>{n(e&&t)}))},P=(e,t)=>n=>{o(e,t)((([e,t])=>{n(e||t)}))},q=e=>t=>{e((e=>{t(!e)}))},B=e=>t=>{i(e,Boolean)(t)},D=(e,t)=>n=>{e((e=>{try{n(JSON.parse(e))}catch(e){t?.(new Error(`Failed to parse JSON: ${e}`))}}))},M=(e,t)=>n=>{e((e=>{try{n(JSON.stringify(e))}catch{t?.(new Error("Failed to convert to JSON"))}}))},z=e=>t=>{i(e,(e=>e[0]))(t)};export{L as and,B as bool,a as branch,J as concatenated,u as constant,v as deadline,p as deferred,m as dirty,z as first,D as fromJson,w as hashTable,g as loading,d as lock,f as memo,q as not,E as onlyChanged,P as or,O as part,S as path,h as polling,y as recordOf,F as regexpMatch,x as regexpMatched,$ as regexpReplaced,A as router,R as set,j as shot,b as task,N as template,T as tick,M as toJson};
//# sourceMappingURL=silentium-components.min.mjs.map
