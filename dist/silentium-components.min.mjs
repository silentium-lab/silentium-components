import{value as e,sourceAll as t,patron as r,sourceOf as n,patronOnce as s,guestCast as l,give as a,subSourceMany as c,sourceFiltered as o,subSource as u,sourceCombined as i,sourceAny as v,sourceChain as p}from"silentium";const m=(n,s,l)=>(e(t([n,s,l]),r((([e,t,r])=>{r.forEach((t=>{t.classList&&t.classList.remove(e)})),t.classList.add(e)}))),l),g=(r,c=!1,o=[],u=[])=>{const i=n(),v=t([i,r]),p={give:e=>(a(JSON.parse(JSON.stringify(e)),i),p),value:t=>(e(v,l(t,(([e,r])=>{e&&a(Object.fromEntries(Object.entries(e).filter((([e,t])=>!!o.includes(e)||!u.includes(e)&&t!==r[e]))),t)}))),p)};return c&&e(r,s(p)),p},d=(t,s)=>{const l=n();return c(l,[t,s]),e(t,r((()=>{l.give(!0)}))),e(s,r((()=>{l.give(!1)}))),l.value},f=(s,l)=>{const o=n();return c(o,[s,l]),e(t([s,l]),r((([e,t])=>{const r=t.split(".");let n=e;r.forEach((e=>{n=n[e]})),void 0!==n&&n!==e&&a(n,o)}))),o.value},E=(t,r,n)=>{let c=null;return u=>{e(n,l(u,(n=>{c&&clearTimeout(c);let l=!1;c=setTimeout((()=>{l||(l=!0,a(new Error("Timeout reached in Deadline class"),t))}),n),e(o(r,(()=>!l)),u),e(r,s((()=>{l=!0})))})))}},O=t=>{const s=n();u(s,t);let l=!1,c=null;return e(t,r((e=>{c=e,l||(l=!0,queueMicrotask((()=>{l=!1,null!==c&&(a(c,s),c=null)})))}))),s},j=t=>{const s=n({});return u(s,t),e(t,r((([e,t])=>{s.value((r=>{r[e]=t}))}))),s.value},b=e=>{const t=Object.keys(e);return i(...Object.values(e))(((e,...r)=>{const n={};r.forEach(((e,r)=>{n[t[r]]=e})),a(n,e)}))},h=(e,t="")=>i(t,...e)(((e,t,...r)=>{a(r.join(t),e)})),w=(e,t,r="")=>i(e,t,r)(((e,t,r,n)=>{a(new RegExp(t,n).test(r),e)})),x=(t,s,l)=>{const a=n();return e(s,r((n=>{e(v([p(t,l),...n.map((e=>p(o(w(e.pattern,t,e.patternFlags),Boolean),e.template)))]),r(a))}))),a.value},L=(e,t,r,n="")=>i(t,e,r,n)(((e,t,r,n,s)=>{a(String(r).replace(new RegExp(t,s),n),e)}));export{h as concatenated,E as deadline,g as dirty,m as groupActiveClass,j as hashTable,d as loading,f as path,b as record,w as regexpMatched,L as regexpReplaced,x as router,O as tick};
//# sourceMappingURL=silentium-components.min.mjs.map
