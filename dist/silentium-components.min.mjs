import{value as e,sourceAll as t,patron as n,sourceOf as r,patronOnce as s,guestCast as l,give as c,subSourceMany as o,sourceFiltered as u,subSource as i,sourceResettable as a,removePatronFromPools as v,sourceCombined as g,sourceAny as p,sourceChain as m}from"silentium";const d=(r,s,l)=>(e(t([r,s,l]),n((([e,t,n])=>{n.forEach((t=>{t.classList&&t.classList.remove(e)})),t.classList.add(e)}))),l),E=(n,o=!1,u=[],i=[])=>{const a=r(),v=t([a,n]),g={give:e=>(c(JSON.parse(JSON.stringify(e)),a),g),value:t=>(e(v,l(t,(([e,n])=>{e&&c(Object.fromEntries(Object.entries(e).filter((([e,t])=>!!u.includes(e)||!i.includes(e)&&t!==n[e]))),t)}))),g)};return o&&e(n,s(g)),g},f=(t,s)=>{const l=r();return o(l,[t,s]),e(t,n((()=>{l.give(!0)}))),e(s,n((()=>{l.give(!1)}))),l.value},O=(s,l)=>{const u=r();return o(u,[s,l]),e(t([s,l]),n((([e,t])=>{const n=t.split(".");let r=e;n.forEach((e=>{r=r[e]})),void 0!==r&&r!==e&&c(r,u)}))),u.value},j=(t,n,r)=>{let o=null;return i=>{e(r,l(i,(r=>{o&&clearTimeout(o);let l=!1;o=setTimeout((()=>{l||(l=!0,c(new Error("Timeout reached in Deadline class"),t))}),r),e(u(n,(()=>!l)),i),e(n,s((()=>{l=!0})))})))}},x=t=>{const s=r();i(s,t);let l=!1,o=null;return e(t,n((e=>{o=e,l||(l=!0,queueMicrotask((()=>{l=!1,null!==o&&(c(o,s),o=null)})))}))),s},b=(t,l,c,o)=>{const u=r(),i=r(),g=a(u,i);let p,m;return e(t,n((t=>{i.give(1),p&&v(p),m&&v(m),l(t)?(p=s(u),e(c,p)):o&&(m=s(u),e(o,m))}))),g},h=(t,s)=>{const l=a(r(),t);return e(s,n((()=>{e(t,l)}))),l.value},w=(t,l,c)=>{const o=r();return e(t,n((t=>{!0===t?e(l,s((e=>{o.give(e)}))):void 0!==c&&e(c,s((e=>{o.give(e)})))}))),o.value},L=t=>{const s=r({});return i(s,t),e(t,n((([e,t])=>{s.value((n=>{n[e]=t}))}))),s.value},R=e=>{const t=Object.keys(e);return g(...Object.values(e))(((e,...n)=>{const r={};n.forEach(((e,n)=>{r[t[n]]=e})),c(r,e)}))},S=(e,t="")=>g(t,...e)(((e,t,...n)=>{c(n.join(t),e)})),T=(e,t,n="")=>g(e,t,n)(((e,t,n,r)=>{c(new RegExp(t,r).test(n),e)})),k=(t,s,l)=>{const c=r();return e(s,n((r=>{e(p([m(t,l),...r.map((e=>m(u(T(e.pattern,t,e.patternFlags),Boolean),e.template)))]),n(c))}))),c.value},y=(e,t,n,r="")=>g(t,e,n,r)(((e,t,n,r,s)=>{c(String(n).replace(new RegExp(t,s),r),e)})),J=(e,t,n="")=>g(e,t,n)(((e,t,n,r)=>{const s=new RegExp(t,r).exec(n);c(s??[],e)})),N=(r,s,l)=>(e(t([r,s,l]),n((([e,t,n])=>{e[t]=n}))),r),q=(e,t)=>g(e,t)(((e,t,n)=>{c(t&&n,e)})),B=(e,t)=>g(e,t)(((e,t,n)=>{c(t||n,e)})),D=t=>n=>{e(t,l(n,(e=>{c(!e,n)})))};export{q as and,w as branch,S as concatenated,j as deadline,h as deferred,E as dirty,b as fork,d as groupActiveClass,L as hashTable,f as loading,D as not,B as or,O as path,R as record,J as regexpMatch,T as regexpMatched,y as regexpReplaced,k as router,N as set,x as tick};
//# sourceMappingURL=silentium-components.min.mjs.map
